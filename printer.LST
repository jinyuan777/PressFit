C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE PRINTER
OBJECT MODULE PLACED IN printer.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe printer.c DB OE BR INCDIR(c:\SiLabs\MCU\Inc)

line level    source

   1          #include <C8051F340.h>
   2          #include <communication2.h>
   3          #include <CPU1X.h>
   4          #include <intrins.h>
   5          #include <A_FORM.c>
   6          #include <format.c>
   7          #include <format1.c>
   8          //============================================
   9          #include "USB_API.h"
  10          #include "compiler_defs.h"
  11          #define INTERRUPT_USBXpress 17
  12          #define U32 unsigned int 
  13          xdata TPacker Packer _at_ 0x0000 ;
  14          xdata TUSB      USB;
  15          //............................
  16          
  17          SEGMENT_VARIABLE(WriteStageLength, U16, SEG_DATA); //  Current write transfer stage length
  18          SEGMENT_VARIABLE(BytesRead, U16, SEG_DATA);  // Number of Bytes Read
  19          SEGMENT_VARIABLE(M_State, U8, SEG_DATA);     // Current Machine State
  20          SEGMENT_VARIABLE(BytesWrote, U16, SEG_DATA); // Number of Bytes Written
  21          SEGMENT_VARIABLE(ReadIndex, U8*, SEG_DATA);
  22          SEGMENT_VARIABLE(BytesToWrite, U16, SEG_DATA);
  23          idata unsigned  char Buffer[56];
  24          //-----------------------------------------------------------------------------
  25          // UART1 Global Variables
  26          //-----------------------------------------------------------------------------
  27          xdata unsigned int errorTime;
  28          
  29          bit IsUSBRxReady;
  30          bit IsDrugReady;
  31          unsigned char RxTimeOutCount=0,CNumber ; // UART 接收超時時間設定
  32          idata unsigned char PNumber;
  33          bit IsCarbonEntry=0;
  34          bit IsCancelPack =0;    
  35          bit IsPrintDate =0;
  36          bit IsPrintNumber =1;
  37          
  38          bit IsCut=0;
  39          bit IsFR=0;
  40          bit IsAgain =0;
  41          bit IsShowCarbonEntry=0;
  42          bit CarbonBTW = 0;
  43          unsigned char *Pointer_Packer = &Packer.UART_Mark;
  44          
  45          bit     IsRxTimeOut =0; 
  46          bit CounterTag = 0,Dir = 0,CarbonTag = 0;
  47          //bit s = 0;
  48          unsigned char Counter,TempPWM = 0; 
  49          unsigned int DrugStartPosition   = 280 ,CarbonError = 0;
  50          unsigned char IMGSer = 0;
  51          //TSize PGMode;
  52          //-----------------------------------------------------------------------------
  53          // 主程式
  54          //-----------------------------------------------------------------------------
  55          
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 2   

  56          void ini_u14(){
  57   1              _Sel = 1;
  58   1              P2=0xEF;
  59   1              Delay(20);
  60   1      
  61   1              P4=0x90;
  62   1              _A1=1;_A0=1;
  63   1              _RD=1;
  64   1              _WR=0;
  65   1              Delay(10);
  66   1              _WR=1;
  67   1              Delay(20);
  68   1              _Sel = 0;
  69   1      }
  70          
  71          void ini_u15(){
  72   1              _Sel = 1;
  73   1              P2=0xFF;
  74   1              _RESET = 1;
  75   1              _RESET = 0;
  76   1              P4=0x92;
  77   1              _A1=1;_A0=1;
  78   1              _RD=1;
  79   1              _WR=0;
  80   1              Delay(10);
  81   1              _WR=1;
  82   1              Delay(20);
  83   1              _Sel = 0;
  84   1      }
  85          
  86          void Powder(unsigned char type,unsigned char pwm)
  87          {
  88   1              if (type == MotorStop)
  89   1              {
  90   2                      u14 = u14PC_PowderStop;
  91   2              }
  92   1              else if (type == MotorLeft)
  93   1              {
  94   2                      u14 = u14PC_PowderLeft;
  95   2              }
  96   1              else if (type ==MotorRight)
  97   1              {
  98   2                      u14 = u14PC_PowderRight;
  99   2          }
 100   1              Delay(50);
 101   1              PCA0CPH0=pwm;
 102   1      }
 103          void _u14pb(unsigned char MOD){
 104   1              _Sel = 1;
 105   1              P2=0xEF;
 106   1              P4=MOD;
 107   1              _RESET = 0;
 108   1              _A1=0;_A0=1;
 109   1              _RD=1;
 110   1              _WR=0;
 111   1              _WR=1;
 112   1              _Sel = 0;
 113   1      }
 114          void _u14pc(unsigned char MOD){
 115   1              _Sel = 1;
 116   1              P2=0xEF;
 117   1              P4=MOD;
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 3   

 118   1              _RESET = 0;
 119   1              _A1=1;_A0=0;
 120   1              _RD=1;
 121   1              _WR=0;
 122   1              _WR=1;  
 123   1              _Sel = 0;
 124   1      }
 125          void _u15pc(unsigned char MOD){
 126   1              _Sel = 1;
 127   1              P2=0xFF;
 128   1              P4 = MOD;
 129   1              _RESET = 0;
 130   1              _RD=1;
 131   1              _A1=1;_A0=0;
 132   1              _WR=0;
 133   1              _WR=1;  
 134   1              _Sel = 0;               
 135   1      }
 136          
 137          void _u15Motor(unsigned char MOD){
 138   1              _Sel = 1;
 139   1              P2=0xFF;
 140   1              P4 = MOD;
 141   1              _RESET = 0;
 142   1              _RD=1;
 143   1              _A1=1;_A0=0;
 144   1              _WR=0;
 145   1              _WR=1;  
 146   1              _Sel = 0;               
 147   1      }
 148          void Cuter(void){
 149   1              Delay(6000);    
 150   1              _Sel = 1;
 151   1              P2=0xEF;
 152   1              P4=0x7F;
 153   1              _RESET = 0;
 154   1              _A1=0;_A0=1;
 155   1              _RD=1;
 156   1              _WR=0;
 157   1              _WR=1;
 158   1              _Sel = 0;
 159   1              Delay(15000);           
 160   1              _Sel = 1;
 161   1              P2=0xEF;
 162   1              P4=0xFF;
 163   1              _RESET = 0;
 164   1              _A1=0;_A0=1;
 165   1              _RD=1;
 166   1              _WR=0;
 167   1              _WR=1;
 168   1              _Sel = 0;
 169   1              Delay(8000);            
 170   1      }
 171          //-----------------------------------------------------------------------------
 172          
 173          void USBPrint(unsigned int Line)
 174          {
 175   1              unsigned char i,d;
 176   1      
 177   1              #define Bottom  0
 178   1              unsigned char tmpEIE1;
 179   1              unsigned char tmpEIE2;
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 4   

 180   1              tmpEIE1 = EIE1;
 181   1              tmpEIE2 = EIE2;
 182   1      
 183   1              EA =0;
 184   1              EIE1 = 0;
 185   1              EIE2 = 0;
 186   1      
 187   1              _u15pc(u15pc |= 0x10);  //      u15 = u15PC_PaperCKH;
 188   1      
 189   1              if (Line < Packer.PgMode[USB.PgMode].Left || Line >= Packer.PgMode[USB.PgMode].Right)
 190   1              {
 191   2                      for (i=1;i<=55;i++)
 192   2                      {
 193   3                              while(!TXBMT);
 194   3                              SPIF=0;
 195   3                              SPI0DAT = 0x00;
 196   3                      }
 197   2              }
 198   1              else 
 199   1              {
 200   2                      for (i=1;i<=55;i++)
 201   2                      {
 202   3                              while(!TXBMT);
 203   3                              SPIF=0;
 204   3                              if (i<=Bottom || i>=Bottom +55 ) 
 205   3                                      SPI0DAT = 0x00;
 206   3                              else                                    
 207   3                                      SPI0DAT = mem[!IMGSer][Line-Packer.PgMode[USB.PgMode].Left][i-Bottom];
 208   3                      }
 209   2              }
 210   1      
 211   1              d=200; while(d--);
 212   1      
 213   1              TPHControl();
 214   1      
 215   1              EA=1;
 216   1              EIE1 = tmpEIE1 ;
 217   1              EIE2 = tmpEIE2 ;
 218   1              FiveStep();
 219   1      
 220   1      }
 221          void USBPack(bit IsDrug,bit IsPrint)
 222          {
 223   1              unsigned int Line,d;
 224   1          unsigned int MotorTime = 1400;
 225   1              Delay(100);
 226   1      
 227   1              if (! IsCancelPack)
 228   1              {
 229   2                      // 溫度提高
 230   2      
 231   2                              Packer.Cpu1.HeaterPWM = TempPWM_Packing ;       
 232   2                              USB.Command = USBCommand_MemroyWrite;   
 233   2                              IsUSBRxReady = 0;
 234   2                              errorTime = Time_USB ;  
 235   2                              for(Line = 0;Line <Packer.PgMode[USB.PgMode].Length ; Line++)
 236   2                              {
 237   3                                      if(IsPrint)
 238   3                                      {
 239   4                                              if (Line == Packer.PgMode[USB.PgMode].Left - 55)
 240   4                                              {
 241   5                                                      u14pb |= 0x40;                          //印字頭上升
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 5   

 242   5                                                      _u14pb(u14pb);
 243   5                                                      Delay(20);
 244   5                                                      Carbon(1);
 245   5                                                      Delay(10);
 246   5                                              }
 247   4                                              else if (Line == Packer.PgMode[USB.PgMode].Right)
 248   4                                              {
 249   5      //                                              u14B = u14PC_PresureStop;       //不確定是否有功能需要測試
 250   5                                                      u14pb &= 0xBF;                          //印字頭下降
 251   5                                                      _u14pb(u14pb);                          //後來加上去確定有用
 252   5                                                      Delay(1000);                            //原始20
 253   5                                                      Carbon(0);
 254   5                                                      Delay(10);
 255   5                                              }                       
 256   4                                              USBPrint(Line); 
 257   4                                      }
 258   3                                      else
 259   3                                      {
 260   4                                              u15 = u15PC_PaperCKH;           
 261   4                                              d = MotorTime;  while(d--);
 262   4                                              u15 = u15PC_PaperCKL;           
 263   4                                              d = MotorTime;  while(d--);
 264   4                                              if(Line < 200)
 265   4                                                      MotorTime --;
 266   4                                              else if(Line > (Packer.PgMode[USB.PgMode].Length - 200))
 267   4                                                      MotorTime ++;
 268   4                                      }
 269   3                              }
 270   2              }       
 271   1              Delay(10);
 272   1              MainMotorPress();
 273   1              while(!IsUSBRxReady&&IsPrint) 
 274   1              {
 275   2              //      CheckErrorCode(ErrorCode_USBConnection);
 276   2                      i_Delay(52);
 277   2              }
 278   1              Packer.Cpu1.ImageNumber ++;
 279   1              ClosePrinter();
 280   1      if(IsDrug)
 281   1      {
 282   2      //      USB.Command = USBCommand_DrugsReady;    
 283   2      //      Packer.Cpu1.State = Cpu1State_Waiting;
 284   2              errorTime = Time_USB ;
 285   2              while(!IsDrugReady) 
 286   2              {
 287   3              //      CheckErrorCode(ErrorCode_USBConnection);
 288   3                      i_Delay(52);
 289   3              }
 290   2              Packer.Cpu1.State = Cpu1State_Packing;
 291   2              Cuter();
 292   2              USB.Command = USBCommand_DrugsReady;    
 293   2              Packer.Cpu1.State = Cpu1State_Waiting;
 294   2              IsDrugReady = 0;
 295   2              while(USB.Command == USBCommand_DrugsReady);
 296   2      
 297   2              
 298   2      }
 299   1      
 300   1              USB.Command = USBCommand_Idel;
 301   1      }
 302          //-----------------------------------------------------------------------------
 303          void TPHControl()
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 6   

 304          {
 305   1              unsigned char d;
 306   1              _u14pb(0xEF);   //LATCH
 307   1              d=10;while(d--);
 308   1              _u14pb(0xFF);   
 309   1      
 310   1              d = 60; while(d--);     
 311   1              // step 1       
 312   1      
 313   1              _u15pc(u15pc &= 0xEF);//        u15 = u15PC_PaperCKL:;
 314   1                      
 315   1              _u14pb(0xFC);//STROBE1,2
 316   1              
 317   1              Delay(10);
 318   1      
 319   1              _u14pb(0xFF);   
 320   1      
 321   1              d = 50; while(d--);     
 322   1              // step 2
 323   1              _u15pc(u15pc |= 0x10);  //      u15 = u15PC_PaperCKH;
 324   1      
 325   1              _u14pb(0xF3);//STROBE3,4        
 326   1      
 327   1              Delay(10);
 328   1        
 329   1              _u14pb(0xFF);
 330   1      }
 331          //-----------------------------------------------------------------------------
 332          void FiveStep()
 333          {
 334   1              unsigned int d;
 335   1              u15 = u15PC_PaperCKL;           
 336   1              d = Time_FiveStepDelay; while(d--);
 337   1              u15 = u15PC_PaperCKH;           
 338   1              d = Time_FiveStepDelay; while(d--);
 339   1              u15 = u15PC_PaperCKL;           
 340   1              d = Time_FiveStepDelay; while(d--);
 341   1      
 342   1      }
 343          
 344          void _u15PAR(){
 345   1              _Sel = 1;
 346   1              P2=0xFF;
 347   1              P4|=0x7F;
 348   1              _WR=1;_RD=0;
 349   1              _A1=0;_A0=0;
 350   1              u15_PA = P4;
 351   1              _Sel = 0;
 352   1      }
 353          void _u15PBR(){
 354   1              _Sel = 1;
 355   1              P2=0xFF;
 356   1              P4|=0xFC;
 357   1              _WR=1;_RD=0;
 358   1              _A1=0;_A0=1;
 359   1              u15_PB = P4;
 360   1              _Sel = 0;
 361   1      }
 362          void _u14PAR(){
 363   1              _Sel = 1;
 364   1              P2=0xEF;
 365   1              P4|=0x0F;
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 7   

 366   1              _WR=1;_RD=0;
 367   1              _A1=0;_A0=0;
 368   1              u14_PA = P4;
 369   1              _Sel = 0;
 370   1      }
 371          
 372          //-----------------------------------------------------------------------------
 373          void Port_Ini(){
 374   1      
 375   1          P0MDOUT   = 0x00;
 376   1              P1MDOUT   = 0x10;
 377   1          P2MDOUT   = 0xFF;
 378   1          P3MDOUT   = 0xFF;
 379   1          P0SKIP    = 0x01;
 380   1              P1SKIP    = 0xC0;
 381   1              P1MDIN    = 0xFF;
 382   1          XBR0      = 0x06;
 383   1          XBR1      = 0x43;
 384   1        //  XBR2      = 0x01;
 385   1              P0MDIN   &= ~0x10;
 386   1      
 387   1      }
 388          
 389          
 390          void Interrupts_Init()
 391          {
 392   1          EIE2      = 0x02;
 393   1          IE        = 0x80;
 394   1      }
 395          
 396          void Timer2_ISR (void) interrupt INTERRUPT_TIMER2 
 397          {
 398   1              TF2H=0;
 399   1              if (RxTimeOutCount ++ >=3)
 400   1              {
 401   2                      TR2 =0;
 402   2                      TMR2H = 0x00;
 403   2                      TMR2L = 0x00;
 404   2                      RxTimeOutCount=0;
 405   2                      Pointer_Packer =&Packer.Cpu1.Command_UART;
 406   2                      IsRxCommand =1;
 407   2              }
 408   1      }
 409          void SYSCLK_Init (void)
 410          {
 411   1         OSCICN |= 0x03;                     // Configure internal oscillator for
 412   1                                             // its maximum frequency
 413   1         RSTSRC  = 0x04;                     // Enable missing clock detector
 414   1      }
 415          void Timer2_Init(){
 416   1              TMR2CN = 0x00;
 417   1              TMR2L  = 0x00;
 418   1              TMR2H  = 0x00;
 419   1          ET2 = 1;
 420   1      }
 421          void EMIF_Init()
 422          {
 423   1              EMI0TC = 0xFF;
 424   1              EMI0CF = 0x17;
 425   1              EMI0CN = 0x00;
 426   1      }
 427          //-----------------------------------------------------------------------------
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 8   

 428          void MemoryClear()
 429          {
 430   1              unsigned int j,x;
 431   1      
 432   1              for (j=0;j<520;j++)
 433   1              {
 434   2                      for(x = 0;x<55;x++)
 435   2                      {
 436   3                              mem[1][j][x] = 0x00;
 437   3                      
 438   3                      }
 439   2              }
 440   1      
 441   1      }
 442          void MainMotorRun()
 443          {
 444   1      
 445   1              if(U14_5){
 446   2                      while(U14_5)
 447   2                      {
 448   3                              PaperMotorForward();                    
 449   3                      }
 450   2                      IsFR =1;
 451   2              }
 452   1              else if(U14_6){
 453   2                      while(U14_6)
 454   2                      {
 455   3                              PaperMotorReverse();            
 456   3                      }
 457   2                      IsFR =1;
 458   2              }
 459   1              else if(U14_7){
 460   2                      PaperMotorLocate();                             
 461   2                      IsFR =1;
 462   2              }
 463   1      
 464   1      }
 465          /*
 466          void DrugLeaveRSW()
 467          {
 468                  bit SWState=0;
 469                  u14 = u14PC_DrugLeft;
 470                  Delay(10);
 471                  PCA0CPH2 = 0x40;
 472                  errorTime = Time_DrugLeaveRSW ;
 473                  while(DrugRSW==0) 
 474                  {
 475                          SWState =1;
 476                          i_Delay(Time_PSDelay);
 477                          CheckErrorCode(ErrorCode_Drug);
 478                  } 
 479          
 480                  if (SWState) Delay(400);
 481                  u14 = u14PC_DrugStop;
 482                  Delay(1600);
 483          }*/
 484          void main()
 485          {   
 486   1      
 487   1              unsigned int i=0x0000,time = 1100,d;
 488   1              //==============================
 489   1          PCA0MD &= ~0x40; 
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 9   

 490   1          USB_Clock_Start();            // Init USB clock *before* calling USB_Init
 491   1          USB_Init(USB_VID,USB_PID,USB_MfrStr,USB_ProductStr,USB_SerialStr,USB_MaxPower,USB_PwAttributes,USB_bcd
             -Device);        
 492   1          USB_Int_Enable();             // Enable USB_API Interrupts
 493   1      
 494   1              //==============================
 495   1      
 496   1              EA = 0;
 497   1      //      UART1_Init();
 498   1              IT01CF = 0x08;
 499   1              SPI_Init();
 500   1              Port_Ini();
 501   1          OSCILLATOR_Init ();                 // Initialize oscillator
 502   1              SMB0CF = 0x88;
 503   1              SMB0CN = 0x00;
 504   1              FLSCL = 0x10;
 505   1          PCA0_Init ();                       // Initialize PCA0
 506   1              ini_u15();
 507   1      
 508   1              ini_u14();
 509   1              EMIF_Init();
 510   1              Timer0_Init();
 511   1              Timer2_Init();
 512   1              ADC0_Init();
 513   1      //      SYSCLK_Init();
 514   1              
 515   1      //      u14pc=0x00;u15pc=0x40;
 516   1              u14pb=0xFF;
 517   1              _u14pb(u14pb);
 518   1      
 519   1              IsFR=1;
 520   1              Packer.Cpu1.Command_USB = Cpu1Command_Idel;     
 521   1              Packer.Cpu1.Command_UART = Cpu1Command_Idel;    
 522   1              Packer.Cpu1.NowNumber =0;
 523   1              Packer.Cpu1.PowderLocation =0;
 524   1              Packer.Cpu1.Thermometer =50 ;   
 525   1              Packer.Cpu1.ImageNumber =0;
 526   1              Packer.ErrorCode =0;
 527   1              Packer.Cpu1.State = Cpu1State_Heating;
 528   1              Packer.Cpu1.PowderStartPosition.W =18;
 529   1              Packer.Cpu1.DrugStartPosition.W   =300;
 530   1              Packer.Cpu1.InitTempTime.W =3000;               
 531   1              Packer.Cpu1.ShakeArray[0].W = 350;
 532   1              Packer.Cpu1.ShakeArray[1].W = 382;              
 533   1              Packer.Cpu1.ShakeArray[2].W = 430;              
 534   1              Packer.Cpu1.ShakeArray[3].W = 442;              
 535   1              Packer.Cpu1.ShakeArray[4].W = 490;              
 536   1              Packer.Cpu1.ShakeArray[5].W = 502;              
 537   1              Packer.Cpu1.VacuumType = VacuumType_Stop ;
 538   1              Packer.Cpu1.ForwardNumber.W =160;                       
 539   1              Packer.Cpu1.ReverseNumber.W =160;                       
 540   1              Packer.Cpu1.PowderCoverOpenNumber =2;   
 541   1              Packer.Cpu1.DrugCoverOpenNumber   =2;   
 542   1              Packer.Cpu1.HeaterPWM = TempPWM_MaxPower;
 543   1      //      Packer.Cpu1.CarbonPWM =0x10;
 544   1              Packer.Cpu1.Message = Message_Heating;
 545   1              Packer.ErrorCode = ErrorCode_NoError;
 546   1              Packer.UART_Mark = UART_Mark;
 547   1              /*
 548   1              Packer.PgMode[0].Left   = 60;
 549   1              Packer.PgMode[0].Right  = 452;
 550   1              Packer.PgMode[0].Length = 512;
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 10  

 551   1              Packer.PgMode[0].SpacePg = 4;*/
 552   1              Packer.PgMode[0].Left    = 120;
 553   1              Packer.PgMode[0].Right   = 560;
 554   1              Packer.PgMode[0].Length  = 585; 
 555   1              Packer.PgMode[0].SpacePg = 4;
 556   1      
 557   1              //9cm           
 558   1              Packer.PgMode[1].Left    = 80; //60
 559   1              Packer.PgMode[1].Right   = 600;//580
 560   1              Packer.PgMode[1].Length  = 750;//750 8.7=720
 561   1              Packer.PgMode[1].SpacePg = 3;
 562   1              
 563   1              //10cm  
 564   1              Packer.PgMode[2].Left    = 300;
 565   1              Packer.PgMode[2].Right   = 820;//820
 566   1              Packer.PgMode[2].Length  = 830;
 567   1              Packer.PgMode[2].SpacePg = 3;
 568   1              
 569   1              USB.Command = USBCommand_Idel;
 570   1      
 571   1              EA = 1;
 572   1      
 573   1      
 574   1              DisableAllDriver();
 575   1              MemoryClear();
 576   1      
 577   1              Packer.Cpu1.HeaterPWM = TempPWM_Standby;
 578   1      
 579   1              #if !IsPowderOnly
              
                              DrugToRight();          
              
                              DrugCoverOpen();        
                      #endif
 585   1      
 586   1              while(1){
 587   2      
 588   2                      byte Command ;
 589   2                      Cpu1CommandIdel();
 590   2                      Packer.Cpu1.State = Cpu1State_Idel;
 591   2      /*
 592   2                      while(Cpu1Command() == Cpu1Command_Idel && !IsPacking)
 593   2                      {
 594   2                              AccessCpu0(Cpu0Command_ShowInfo);
 595   2      
 596   2                              #if IsMainMotorButton
 597   2                                      //MainMotorRun();
 598   2                              #endif
 599   2      
 600   2                              if (RHall != 0 )
 601   2                              {
 602   2                                      Delay(3000);                                    
 603   2                                      //PowderLocate();
 604   2                              }
 605   2                              Delay(30000);
 606   2                      }
 607   2      */
 608   2                      //SpacePacking(1);
 609   2                      Command = Cpu1Command() ;
 610   2                      Packer.Cpu1.State = Cpu1State_Busy;     
 611   2      //              AccessCpu0(Cpu0Command_ShowInfo);
 612   2      
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 11  

 613   2                      if(Command == Cpu1Command_PackStart)
 614   2                      {
 615   3                              Packing();      
 616   3                              Delay(200);
 617   3                              Packer.Cpu1.Command_UART = Cpu1Command_Idel;
 618   3                      }
 619   2                      else if (Command == Cpu1Command_PaperMotorLocate)
 620   2                      {
 621   3                              time = 1000;
 622   3                              u15 = u15PC_PaperCW ;
 623   3                              Delay(10);
 624   3                              u15 = u15PC_PaperEnable;
 625   3                              Delay(10);
 626   3                              for (i=0;i<640;i++)
 627   3                              {
 628   4                                      u15 = u15PC_PaperCKH;           
 629   4                                      d = time;       while(d--);
 630   4                                      u15 = u15PC_PaperCKL;           
 631   4                                      d = time;       while(d--);
 632   4                                      u15 = u15PC_PaperCKH;           
 633   4                                      d = time;       while(d--);
 634   4                                      u15 = u15PC_PaperCKL;           
 635   4                                      d = time;       while(d--);
 636   4                                      u15 = u15PC_PaperCKH;           
 637   4                                      d = time;       while(d--);
 638   4                                      u15 = u15PC_PaperCKL;           
 639   4                                      d = time;       while(d--);
 640   4                              }
 641   3                              u15 = u15PC_PaperDisable;               
 642   3                              //Cuter();
 643   3                              MainMotorPress();
 644   3                      }
 645   2                      else if(Command == Cpu1Command_MototPressFit)
 646   2                      {
 647   3                              u15 = u15PC_PaperPressON;
 648   3                              Delay(10);
 649   3                              errorTime = Time_PresurePS ;
 650   3                              do 
 651   3                              {
 652   4                                      i_Delay(Time_PSDelay);
 653   4                                      CheckErrorCode(ErrorCode_PresureDown);  
 654   4                              } while(PowderCounterPS==1);
 655   3                              
 656   3                              Delay(500);
 657   3                              do 
 658   3                              {
 659   4                                      i_Delay(Time_PSDelay);
 660   4                                      CheckErrorCode(ErrorCode_PresureDown);  
 661   4                              } while(PowderCounterPS==0);
 662   3                              u15 = u15PC_PaperPressOFF;
 663   3                              Delay(100);
 664   3                      }
 665   2                      else if(Command == Cpu1Command_USBPackStart)
 666   2                      {
 667   3                              USBPacking();
 668   3                              //_u14pb(0x7F);//STROBE1,2
 669   3                              Delay(100);
 670   3                              //_u14pb(0xFF);//STROBE1,2
 671   3                      }
 672   2                      Delay(1000);
 673   2      
 674   2              }
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 12  

 675   1      }
 676          void MainMotorPress()
 677          {
 678   1              u15 = u15PC_PaperPressON;
 679   1              Delay(10);
 680   1              errorTime = Time_PresurePS ;
 681   1              do 
 682   1              {
 683   2                      i_Delay(Time_PSDelay);
 684   2                      CheckErrorCode(ErrorCode_PresureDown);  
 685   2              } while(PowderCounterPS==1);
 686   1              
 687   1              Delay(500);
 688   1              do 
 689   1              {
 690   2                      i_Delay(Time_PSDelay);
 691   2                      CheckErrorCode(ErrorCode_PresureDown);  
 692   2              } while(PowderCounterPS==0);
 693   1              u15 = u15PC_PaperPressOFF;
 694   1              Delay(100);
 695   1      }
 696          //-----------------------------------------------------------------------------
 697          unsigned char Read_S=0x00, Mark = 0xFF;
 698          void USBPacking() 
 699          {
 700   1      
 701   1              Packer.Cpu1.State = Cpu1State_Packing;
 702   1              //AccessCpu0(Cpu0Command_ShowLeftDownGroupBox);
 703   1      
 704   1              //CheckPauseState(1);
 705   1      
 706   1              if (! IsCancelPack)
 707   1              {
 708   2              
 709   2      
 710   2                      PackForUSB();
 711   2                      IsPacking =0; 
 712   2      
 713   2              }
 714   1      
 715   1      
 716   1              Delay(2000);
 717   1              Packer.Cpu1.State = Cpu1State_Idel;
 718   1              Packer.Cpu1.NowNumber =0;
 719   1              //AccessCpu0(Cpu0Command_ShowPackFinish);
 720   1      
 721   1              Packer.Cpu1.Message = Message_PackFinish;
 722   1      
 723   1              Delay(4000);
 724   1              MemoryClear();
 725   1              //AccessCpu0(Cpu0Command_ShowSystemReady);
 726   1              Packer.Cpu1.Message = Message_SystemReady;              
 727   1      
 728   1              Packer.Cpu1.HeaterPWM = TempPWM_Standby ;               
 729   1              Cpu1CommandIdel();      
 730   1      }
 731          //-----------------------------------------------------------------------------
 732          void DrugCoverOpen()
 733          {
 734   1              unsigned char i;
 735   1              i = Packer.Cpu1.DrugCoverOpenNumber ;
 736   1              if (i>4) i=2;
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 13  

 737   1      
 738   1              u14 = u14PC_DrugCoverStart ;
 739   1              Delay(50);
 740   1              while(i--)
 741   1              {
 742   2                      errorTime = Time_DrugCoverPS ;
 743   2                      do 
 744   2                      {
 745   3                              i_Delay(Time_PSDelay);
 746   3                              CheckErrorCode(ErrorCode_DrugCover);
 747   3                      } while(DrugCoverPS==1) ;
 748   2      
 749   2                      errorTime = Time_DrugCoverPS ;
 750   2                      do 
 751   2                      {
 752   3                              i_Delay(Time_PSDelay);
 753   3                              CheckErrorCode(ErrorCode_DrugCover);
 754   3                      } while(DrugCoverPS==0) ;
 755   2              }
 756   1              u14 = u14PC_DrugCoverStop ;
 757   1              Delay(800);
 758   1      }
 759          //-----------------------------------------------------------------------------
 760          
 761          void PackForUSB()
 762          {
 763   1              unsigned char PackNum = USB.PackNumber + Packer.PgMode[USB.PgMode].SpacePg;
 764   1      
 765   1              Packer.Cpu1.NowNumber = 0;
 766   1              //-----------------------------------------------
 767   1              
 768   1              USB.Command = USBCommand_MemroyWrite;   
 769   1              IsUSBRxReady = 0;
 770   1              errorTime = Time_USB ;
 771   1              while(!IsUSBRxReady) 
 772   1              {
 773   2              //      CheckErrorCode(ErrorCode_USBConnection);
 774   2                      i_Delay(52);
 775   2              }
 776   1      
 777   1      
 778   1              //-----------------------------------------------
 779   1              u15 = u15PC_PaperCW ;
 780   1              Delay(10);
 781   1              u15 = u15PC_PaperEnable;
 782   1              Delay(10);
 783   1              Carbonini();
 784   1              IsPacking =1;
 785   1      
 786   1              Packer.Cpu1.ImageNumber =0;
 787   1              USB.Command = USBCommand_DrugsReady;    
 788   1              Packer.Cpu1.State = Cpu1State_Waiting;  
 789   1              IsDrugReady = 0;
 790   1              MainMotorPress();
 791   1          IsShake = USB.IsShake;
 792   1              for (PNumber=1; PNumber <= PackNum; PNumber++)
 793   1              {
 794   2                      if(PNumber == PackNum)
 795   2                      {
 796   3                              Packer.Cpu1.NowNumber = PNumber-2 ;
 797   3                              Packer.Cpu1.ImageNumber =0;
 798   3      
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 14  

 799   3                              USBPack(0,0);                   
 800   3                              if (IsCancelPack)
 801   3                              {
 802   4                                      return ;
 803   4                              }
 804   3                      }
 805   2                      else if (PNumber > (PackNum-Packer.PgMode[USB.PgMode].SpacePg))         
 806   2                      {
 807   3                              Packer.Cpu1.NowNumber = PNumber-2 ;
 808   3                              Packer.Cpu1.ImageNumber =0;
 809   3      
 810   3                              USBPack(1,0);                   
 811   3                              if (IsCancelPack)
 812   3                              {
 813   4                                      return ;
 814   4                              }
 815   3                      }
 816   2      
 817   2                      else if (PNumber <=Packer.PgMode[USB.PgMode].SpacePg)                                           
 818   2                      {
 819   3      
 820   3                              Packer.Cpu1.NowNumber = 0;
 821   3      
 822   3                              USBPack(0,1);                   
 823   3                                                              
 824   3                              if (IsCancelPack)
 825   3                              {
 826   4                                      return ;
 827   4                              }
 828   3                      }
 829   2      
 830   2                      else if (PNumber > Packer.PgMode[USB.PgMode].SpacePg && PNumber <= PackNum-Packer.PgMode[USB.PgMode].Spa
             -cePg)
 831   2                      {
 832   3      
 833   3                              Packer.Cpu1.NowNumber = PNumber-2 ;     
 834   3                              USBPack(1,1);                   
 835   3                              if (IsCancelPack)
 836   3                              {
 837   4                                      return ;
 838   4                              }
 839   3                      }
 840   2      
 841   2              }
 842   1              Cuter();
 843   1              USBPack(0,0);
 844   1              USBPack(0,0);
 845   1              USBPack(0,0);
 846   1              Packer.Cpu1.Message = Message_PackSpace;
 847   1      
 848   1              u15 = u15PC_PaperDisable;
 849   1              Delay(10);
 850   1      
 851   1      }
 852          void SpacePacking(byte SpaceNumber)
 853          {
 854   1              for (PNumber=1; PNumber <= SpaceNumber; PNumber++)      // 空包
 855   1              {
 856   2                      Packer.Cpu1.NowNumber = PNumber ;
 857   2                      SpacePack();
 858   2                      if (IsCancelPack)
 859   2                      {
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 15  

 860   3                              return ;
 861   3                      }
 862   2                              Delay(500);
 863   2                              MainMotorPress();
 864   2              }       
 865   1      }
 866          
 867          //-----------------------------------------------------------------------------
 868          void CheckPauseState(bit IsPrint)
 869          {
 870   1      //      unsigned char tag=0;
 871   1      
 872   1              Packer.Cpu1.State = Cpu1State_Packing;
 873   1      //      AccessCpu0(Cpu0Command_ShowPackInfo);
 874   1      
 875   1              IsCancelPack =0;
 876   1              if (PaperEntrySW )
 877   1              {
 878   2                      Packer.Cpu1.State = Cpu1State_PackPause ;
 879   2                      AccessCpu0(Cpu0Command_ShowPaperEntry);
 880   2                      Packer.Cpu1.Message = Message_PaperEntryAlerm ;
 881   2      //              tag = 1;
 882   2              }
 883   1      
 884   1              if (IsPackPause)
 885   1              {
 886   2                      Packer.Cpu1.State = Cpu1State_PackPause ;
 887   2                      AccessCpu0(Cpu0Command_ShowPackPause);
 888   2                      Packer.Cpu1.Message = Message_PackPause ;
 889   2              }
 890   1      
 891   1          if (IsCarbonEntry && IsPrint) 
 892   1              {
 893   2                      IsShowCarbonEntry =1;
 894   2                      Packer.Cpu1.State = Cpu1State_PackPause ;
 895   2                      AccessCpu0(Cpu0Command_ShowCarbonEntry);
 896   2                      Packer.Cpu1.Message = Message_CarbonEntryAlerm ;
 897   2      
 898   2              }
 899   1              
 900   1              else 
 901   1              {
 902   2                      if (!IsShowCarbonEntry)
 903   2                      {
 904   3                              AccessCpu0(Cpu0Command_ShowCarbonNoEntry);
 905   3      //                      AccessUSB(USBCommand_ShowCarbonNoEntry);
 906   3                      }
 907   2              }
 908   1      
 909   1              if (PaperEntrySW ==1 || IsPackPause || IsShowCarbonEntry) 
 910   1              {
 911   2                      Packer.Cpu1.State = Cpu1State_PackPause ;
 912   2                      AccessCpu0(Cpu0Command_ShowInfo) ;
 913   2                      u15 = u15PC_PaperDisable;
 914   2                      Delay(10);
 915   2                      u15 = u15PC_SharkerOFF ;
 916   2                      ClosePrinter();
 917   2                      if (IsPrint)
 918   2                      {
 919   3                              Carbon(0);
 920   3                              Delay(10);
 921   3                              //PresureDown();
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 16  

 922   3                      }
 923   2                      
 924   2                      while(1)
 925   2                      {                       
 926   3                              Packer.Cpu1.State = Cpu1State_PackPause ;
 927   3                              AccessCpu0(Cpu0Command_ShowInfo) ;      
 928   3      
 929   3                              if (Cpu1Command() == Cpu1Command_PackContinue && PaperEntrySW ==0) {
 930   4                                      Cpu1CommandIdel() ;     
 931   4                                      Packer.Cpu1.Message = Message_SystemReady ;
 932   4                                      PaperMotorLocate();     
 933   4                                      ShowPackType();
 934   4                                      CNumber += 2;
 935   4                                      PNumber -= 1;
 936   4                                      u15 = u15PC_PaperEnable;
 937   4                                      if (IsPrint)
 938   4                                      {
 939   5                                              //PresureUp();
 940   5                                              Carbon(1);
 941   5                                      }
 942   4                                      Carbonini();
 943   4                                      IsShowCarbonEntry = 0;
 944   4                                      IsCancelPack =0;
 945   4                                      Packer.Cpu1.State = Cpu1State_Packing ;
 946   4                                      AccessCpu0(Cpu0Command_ShowPackContinue);
 947   4                                      break ;
 948   4                              }       
 949   3                              // 停止包裝
 950   3                              else if (Cpu1Command() == Cpu1Command_PackStop) 
 951   3                              {
 952   4                                      Cpu1CommandIdel() ;
 953   4                                      Packer.Cpu1.State = Cpu1State_Idel ;
 954   4                                      AccessCpu0(Cpu0Command_ShowPackStop);
 955   4                                      Carbonini();
 956   4                                      IsCancelPack =1;
 957   4                                      Packer.Cpu1.Message = Message_SystemReady ;
 958   4                                      IsPacking =0;
 959   4                                      break ;
 960   4                              }
 961   3                              #if IsMainMotorButton
 962   3                                      MainMotorRun();
 963   3                              #endif
 964   3                              Delay(30000);
 965   3                      }
 966   2      
 967   2                      AccessCpu0(Cpu0Command_ShowPaperReady);
 968   2              }
 969   1      }
 970          //-----------------------------------------------------------------------------
 971          void Packing()
 972          {
 973   1      
 974   1              Packer.Cpu1.State = Cpu1State_Packing;
 975   1              AccessCpu0(Cpu0Command_ShowLeftDownGroupBox);
 976   1      
 977   1              AccessCpu0(Cpu0Command_TxPackInfo);
 978   1      
 979   1              CheckPauseState(0);
 980   1              if (! IsCancelPack)
 981   1              {
 982   2                      if (PaperMotorPS != 1)
 983   2                      {
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 17  

 984   3                              PaperMotorLocate();             
 985   3                      }
 986   2      
 987   2                      Packer.Cpu1.HeaterPWM = TempPWM_Packing ;
 988   2                      
 989   2              
 990   2      //              if (IsAutoOpen)
 991   2                      {
 992   3                              if (Packer.Cpu0.PackType == PackType_Powder ||  Packer.Cpu0.PackType == PackType_Mix) 
 993   3                              {
 994   4      
 995   4                                      PowderCoverOpen();              
 996   4                                      
 997   4                                      //Packer.Cpu1.VacuumType = VacuumType_LowSpeed;
 998   4                              }
 999   3                              if (Packer.Cpu0.PackType == PackType_Drug || Packer.Cpu0.PackType == PackType_Mix) 
1000   3                              {
1001   4                                      DrugCoverOpen();                
1002   4                              }
1003   3                      }
1004   2                      IsPacking =1;
1005   2                      if (IsPrintPack )       
1006   2                      {
1007   3                              PackWithPrint();                
1008   3                      }
1009   2                      else                            
1010   2                      {
1011   3                              PackWithoutPrint();
1012   3                      }
1013   2                      IsPacking =0;   
1014   2                      #if !IsPowderOnly
                                      DrugToRight();  
                              #endif                          
1017   2                      IsPacking =0;
1018   2                      if ( Packer.Cpu0.PackType == PackType_Powder || 
1019   2                           Packer.Cpu0.PackType == PackType_Mix ) 
1020   2                      {
1021   3                              if (IsCancelPack)
1022   3                              { 
1023   4                                      Packer.Cpu1.VacuumType = VacuumType_Stop ;
1024   4                                      PowderNumber();
1025   4                              }
1026   3                              else
1027   3                              {
1028   4                                      AutoClear(); 
1029   4                              }
1030   3                      }
1031   2      
1032   2              }
1033   1      
1034   1              Delay(1000);
1035   1              Packer.Cpu1.State = Cpu1State_Idel;
1036   1              Packer.Cpu1.NowNumber =0;
1037   1              AccessCpu0(Cpu0Command_ShowPackFinish);
1038   1      //      AccessUSB(USBCommand_Idel);
1039   1              Packer.Cpu1.Message = Message_PackFinish;       
1040   1              Delay(8000);
1041   1              MemoryClear();
1042   1              AccessCpu0(Cpu0Command_ShowSystemReady);
1043   1              Packer.Cpu1.Message = Message_SystemReady;                      
1044   1              Packer.Cpu1.HeaterPWM = TempPWM_Standby ;               
1045   1              Cpu1CommandIdel();
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 18  

1046   1      }
1047          //-----------------------------------------------------------------------------
1048          void PackWithoutPrint()
1049          {
1050   1              unsigned char PNumber;
1051   1              u15 = u15PC_PaperResetH;
1052   1              Delay(10);
1053   1              u15 = u15PC_PaperCW ;
1054   1              Delay(10);
1055   1              u15 = u15PC_PaperEnable;
1056   1              Delay(10);
1057   1              IsPacking =1;
1058   1      
1059   1              // 包裝藥粉.錠劑.混合
1060   1              ShowPackType();
1061   1              for (PNumber=1 ; PNumber <= Packer.Cpu1.PowderLocation ; PNumber++)     
1062   1              {
1063   2                      Packer.Cpu1.NowNumber =PNumber;
1064   2                      OnePack(Packer.Cpu0.PackType , PrintFalse,IsCut);
1065   2                      if(PNumber==1)
1066   2                              IsCut=1;
1067   2                      else
1068   2                              IsCut=0;
1069   2                      if (IsCancelPack)
1070   2                      {
1071   3                              // 取消包裝
1072   3                              return ;
1073   3                      }
1074   2              }
1075   1      
1076   1              AccessCpu0(Cpu0Command_ShowPackSpace);
1077   1      
1078   1              #if IsCuterOk
1079   1                      if(IsAutoCut)
1080   1                      {
1081   2                              SpacePacking(1);
1082   2                              Delay(5000);
1083   2                              _One(PackType_Space ,PrintFalse);
1084   2                              Delay(5000);
1085   2                              // 主馬達定位
1086   2                              PaperMotorLocate();
1087   2                      }       
1088   1                      else
1089   1                              SpacePacking(Packer.Cpu0.SpaceNumber);
1090   1              #else 
                              SpacePacking(Packer.Cpu0.SpaceNumber);          
                      #endif  
1093   1      //      PaperMotorLocate();
1094   1      
1095   1              u15 = u15PC_PaperDisable;
1096   1              Delay(10);
1097   1      }
1098          //========================================================
1099          void _One(unsigned char Type,bit IsPrint)
1100          {
1101   1              unsigned int n;
1102   1      
1103   1              CheckPauseState(IsPrint);
1104   1              u15 = u15PC_PaperEnable;
1105   1              Delay(10);
1106   1              if (! IsCancelPack)
1107   1              {
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 19  

1108   2                      for (n=0;n< CutterPosition ;n++)
1109   2                      {
1110   3                              OneStep(Time_PaperMotorDelay);  
1111   3                      }
1112   2      
1113   2              Delay(15000);
1114   2                              
1115   2              Cuter();
1116   2                              
1117   2              u15 = u15PC_SharkerOFF ;
1118   2              ClosePrinter();
1119   2              }
1120   1      }
*** WARNING C280 IN LINE 1099 OF printer.c: 'Type': unreferenced local variable
1121          void OnePack(unsigned char Type,bit IsPrint,bit IsCuts)
1122          {
1123   1              unsigned int n;
1124   1      
1125   1              CheckPauseState(IsPrint);
1126   1              if (! IsCancelPack)
1127   1              {
1128   2              
1129   2                      PCA0CPH0 = 0x60;
1130   2                      for (n=0;n< 640 ;n++)
1131   2                      {
1132   3      //                      TR1 = 0;
1133   3                              if (IsPrint) 
1134   3                              {
1135   4                                      Print(n,PNumber-1);
1136   4                                      if(n==CutterPosition&&IsCuts==1){
1137   5                                      #if IsCuterOk
1138   5                                              if(IsAutoCut)
1139   5                                              {
1140   6                                                      
1141   6                                                              Carbon(0);
1142   6                                                              Delay(15000);
1143   6                                                              EA = 0;Cuter();EA = 1;
1144   6                                                              Delay(10000);
1145   6                                                              Carbon(1);                      
1146   6                                              
1147   6                                              }
1148   5                                      #endif
1149   5                                      }
1150   4                              }
1151   3      
1152   3                              else     
1153   3                              {
1154   4                                      OneStep(Time_PaperMotorDelay-40);
1155   4                                      if(n==CutterPosition&&IsCuts==1){
1156   5                                      #if IsCuterOk
1157   5                                              if(IsAutoCut)
1158   5                                              {                                               
1159   6                                                      
1160   6                                                              Delay(15000);
1161   6                                                              EA = 0;Cuter();EA = 1;
1162   6                                                              Delay(10000);           
1163   6                                                                                                      
1164   6                                              }
1165   5                                      #endif  
1166   5                                      }
1167   4                              }
1168   3                              if (Type == PackType_Drug )             
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 20  

1169   3                              {
1170   4                                      // 錠劑
1171   4                                      if (n == DrugStartPosition) 
1172   4                                              IsDrugMove =1;
1173   4                              }
1174   3                              
1175   3                              else if (Type == PackType_Mix)  
1176   3                              {
1177   4                                      // 混合 
1178   4                                      if (n == DrugStartPosition)   
1179   4                                              IsDrugMove   =1;
1180   4                                      Shake(n) ;
1181   4                              }
1182   3                      }
1183   2      
1184   2              u15pc &= 0xF7;
1185   2      
1186   2              ClosePrinter();
1187   2              }
1188   1      }
1189          //-----------------------------------------------------------------------------
1190          void Shake(unsigned int n)
1191          {
1192   1              if (IsShake ==0) return;
1193   1              if ( n == Packer.Cpu1.ShakeArray[0].W || 
1194   1                       n == Packer.Cpu1.ShakeArray[2].W || 
1195   1                       n == Packer.Cpu1.ShakeArray[4].W )
1196   1              {
1197   2                      //u15 = u15PC_SharkerON ;
1198   2                      u15pc |= 0x08;
1199   2              }
1200   1              else if ( n == Packer.Cpu1.ShakeArray[1].W || 
1201   1                                n == Packer.Cpu1.ShakeArray[3].W || 
1202   1                                n == Packer.Cpu1.ShakeArray[5].W )
1203   1              {
1204   2                      //u15 = u15PC_SharkerOFF ;
1205   2                      u15pc &= 0xF7;
1206   2              }
1207   1              //Delay(10);
1208   1      }
1209          //-----------------------------------------------------------------------------
1210          void Carbonini()
1211          {
1212   1              CarbonTag = CarbonHall;
1213   1              CarbonError = 0;
1214   1              IsCarbonEntry = 0;
1215   1      
1216   1      }
1217          //-----------------------------------------------------------------------------
1218          void PackWithPrint()
1219          {
1220   1              unsigned char PackTotal = Packer.Cpu1.PowderLocation +2;
1221   1      
1222   1              HeadWithPrint();
1223   1      
1224   1              //PresureUp();
1225   1      
1226   1              Carbon(1);
1227   1              u15 = u15PC_PaperCW ;
1228   1              Delay(10);
1229   1              u15 = u15PC_PaperEnable;
1230   1              Delay(10);
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 21  

1231   1              Carbonini();
1232   1              IsPacking =1;
1233   1      
1234   1              ShowPackType();
1235   1              for (PNumber=1;PNumber<= PackTotal;PNumber++)
1236   1              {
1237   2                      if(PNumber == 4)
1238   2                              IsCut = 1;
1239   2                      else
1240   2                              IsCut = 0;
1241   2                      if (PNumber == PackTotal-1)     
1242   2                      {
1243   3                              Carbon(0);
1244   3                              Delay(10);
1245   3                              
1246   3                      //      PresureDown();  
1247   3      
1248   3                              Packer.Cpu1.NowNumber =PNumber-2 ;              
1249   3      
1250   3                              OnePack(Packer.Cpu0.PackType , PrintFalse,IsCut);
1251   3                              if (IsCancelPack)
1252   3                              {
1253   4                                      return ;
1254   4                              }
1255   3                      }
1256   2                      else if (PNumber >= PackTotal)          
1257   2                      {
1258   3                              Packer.Cpu1.NowNumber =PNumber-2 ;              
1259   3                              OnePack(Packer.Cpu0.PackType , PrintFalse,IsCut);
1260   3                              if (IsCancelPack)
1261   3                              {
1262   4                                      return ;
1263   4                              }
1264   3                      }
1265   2                      else if (PNumber <=2 )                                  
1266   2                      {
1267   3                              Packer.Cpu1.NowNumber =0;
1268   3      
1269   3                              OnePack(PackType_Space , PrintTrue,IsCut);
1270   3                              if (IsCancelPack)
1271   3                              {
1272   4                                      return;
1273   4                              }
1274   3                      }
1275   2                      else if (PNumber > 2 && PNumber < PackTotal-1)
1276   2                      {
1277   3                              Packer.Cpu1.NowNumber =PNumber-2 ;              
1278   3                              
1279   3                              OnePack(Packer.Cpu0.PackType , PrintTrue,IsCut);
1280   3                              if (IsCancelPack)
1281   3                              {
1282   4                                      return;
1283   4                              }
1284   3                      }
1285   2      
1286   2      
1287   2              }
1288   1              #if IsCuterOk
1289   1                      if(IsAutoCut)
1290   1                      {
1291   2                              SpacePacking(1);
1292   2                              Delay(5000);
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 22  

1293   2                              _One(PackType_Space ,PrintFalse);
1294   2                              Delay(5000);
1295   2                              // 主馬達定位
1296   2                              PaperMotorLocate();
1297   2                      }       
1298   1                      else
1299   1                              SpacePacking(Packer.Cpu0.SpaceNumber);
1300   1              #else 
                              SpacePacking(Packer.Cpu0.SpaceNumber);          
                      #endif  
1303   1      //      PaperMotorLocate();     // 主馬達定位
1304   1      
1305   1              u15 = u15PC_PaperDisable;
1306   1              Delay(10);
1307   1      }
1308          //-----------------------------------------------------------------------------
1309          void Print(unsigned int Line,signed int Number)
1310          {
1311   1              unsigned char i;
1312   1              unsigned char tmpEIE1;
1313   1              unsigned char tmpEIE2;
1314   1      
1315   1              unsigned int Shift = 0 ;
1316   1              
1317   1              u15 = u15PC_PaperCKH;
1318   1              tmpEIE1 = EIE1;
1319   1              tmpEIE2 = EIE2;
1320   1      //      EA =0;
1321   1      //      EIE1 = 0;
1322   1      //      EIE2 = 0;
1323   1      
1324   1      
1325   1              if (Line < Packer.PgMode[0].Left || Line >= Packer.PgMode[0].Right)
1326   1              {
1327   2                      for (i=1;i<=80;i++)
1328   2                      {
1329   3                              while(!TXBMT);
1330   3                              SPIF=0;
1331   3                              SPI0DAT = 0x00;
1332   3                      }
1333   2              }
1334   1              else 
1335   1              {
1336   2                      unsigned char n,k;
1337   2                      for (i=0 ; i < 21 ; i++)
1338   2                      {
1339   3                              while(!TXBMT);
1340   3                              SPIF=0;
1341   3                              SPI0DAT = 0x00;
1342   3                      }
1343   2      
1344   2                      if (IsPrintDate)
1345   2                      {
1346   3                              for (i=0 ; i < 4 ; i++)
1347   3                              {
1348   4                                      while(!TXBMT);
1349   4                                      SPIF=0;
1350   4                                      if (Line >=Shift && Line < Shift+32 )
1351   4                                      {
1352   5                                              unsigned char n = 2;
1353   5                                              SPI0DAT = cA11[n][Line - Shift][i] ;
1354   5                                      }
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 23  

1355   4                                      else if (Line >=Shift +32 && Line < Shift+64 )
1356   4                                      {
1357   5                                              unsigned char n = 0;
1358   5                                              SPI0DAT = cA11[n][Line - Shift -32][i] ;
1359   5                                      }
1360   4                                      else if (Line >=Shift +64 && Line < Shift+96 )
1361   4                                      {
1362   5                                              unsigned char n = 1;
1363   5                                              SPI0DAT = cA11[n][Line - Shift -64][i] ;
1364   5                                      }
1365   4                                      else if (Line >=Shift +96 && Line < Shift+128 )
1366   4                                      {
1367   5                                              unsigned char n = 1;
1368   5                                              SPI0DAT = cA11[n][Line - Shift -96][i] ;
1369   5                                      }
1370   4                                      else if (Line >=Shift +128 && Line < Shift+160 )
1371   4                                      {
1372   5                                              SPI0DAT = cA11[10][Line - Shift -128][i] ;
1373   5                                      }
1374   4                                      
1375   4                                      else if (Line >=Shift +160 && Line < Shift+192 )
1376   4                                      {
1377   5                                              unsigned char n = 0;
1378   5                                              SPI0DAT = cA11[n][Line - Shift -160][i] ;
1379   5                                      }
1380   4                                      else if (Line >=Shift +192 && Line < Shift+224 )
1381   4                                      {
1382   5                                              unsigned char n = 3;
1383   5                                              SPI0DAT = cA11[n][Line - Shift -192][i] ;
1384   5                                      }
1385   4                                      else if (Line >=Shift +224 && Line < Shift+256)
1386   4                                      {
1387   5                                              SPI0DAT = cA11[10][Line - Shift -224][i] ;
1388   5                                      }
1389   4      
1390   4                                      else if (Line >=Shift +256 && Line < Shift+288 )
1391   4                                      {
1392   5                                              unsigned char n = 0;
1393   5                                              SPI0DAT = cA11[n][Line - Shift -256][i] ;
1394   5                                      }
1395   4                                      else if (Line >=Shift +288 && Line < Shift+320 )
1396   4                                      {
1397   5                                              unsigned char n = 9;
1398   5                                              SPI0DAT = cA11[n][Line - Shift -288][i] ;
1399   5                                      }
1400   4                                      else SPI0DAT = 0x00;
1401   4                              }
1402   3                      }
1403   2      
1404   2                      if (IsPrintNumber)
1405   2                      {
1406   3                              for (i=0 ; i < 4 ; i++) 
1407   3                              {
1408   4                                      while(!TXBMT);
1409   4                                      SPIF=0;
1410   4                                      if (Line >=Shift && Line < Shift+32 )
1411   4                                      {
1412   5                                              unsigned char n = (Number +1) /10;
1413   5                                              SPI0DAT = cA11[n][Line - Shift][i] ;
1414   5                                      }
1415   4                                      else if (Line >=Shift +32 && Line < Shift+64 )
1416   4                                      {
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 24  

1417   5                                              unsigned char n = (Number +1) %10;
1418   5                                              SPI0DAT = cA11[n][Line - Shift -32][i] ;
1419   5                                      }
1420   4                                      else if (Line >=Shift +64 && Line < Shift+96 )
1421   4                                      {
1422   5                                              SPI0DAT = cA11[10][Line - Shift -64][i] ;
1423   5                                      }
1424   4                                      else if (Line >=Shift +96 && Line < Shift+128 )
1425   4                                      {
1426   5                                              unsigned char n = Packer.Cpu0.TotalNumber /10;
1427   5                                              SPI0DAT = cA11[n][Line - Shift -96][i] ;
1428   5                                      }
1429   4                                      else if (Line >=Shift +128 && Line < Shift+160 )
1430   4                                      {
1431   5                                              unsigned char n = Packer.Cpu0.TotalNumber %10;
1432   5                                              SPI0DAT = cA11[n][Line - Shift -128][i] ;
1433   5                                      }
1434   4                                      else SPI0DAT = 0x00;
1435   4                              }
1436   3                      }
1437   2      
1438   2                      for (i=0 ; i < 9 ; i++) 
1439   2                      {
1440   3                              while(!TXBMT);
1441   3                              SPIF=0;
1442   3                              SPI0DAT = 0;
1443   3                      }
1444   2      
1445   2                      k =0;
1446   2                      for (i=0; i<=3; i++)            // 4
1447   2                      {
1448   3                              if ( Packer.Cpu0.PrintItem[i] != 0 ) k++;
1449   3                      }
1450   2      
1451   2                      n =     (Number % k) *8  ;
1452   2      
1453   2                      for (i=0 ; i < 8 ; i++) 
1454   2                      {
1455   3                              while(!TXBMT);
1456   3                              SPIF=0;
1457   3                              SPI0DAT = mem[Line][n+i];
1458   3                      }
1459   2      
1460   2                      for (i=0 ; i < 4 ; i++) 
1461   2                      {
1462   3                              while(!TXBMT);
1463   3                              SPIF=0;
1464   3                              SPI0DAT = 0x00;
1465   3                      }
1466   2      
1467   2                      for (i=0 ; i < 4 ; i++) 
1468   2                      {
1469   3                              while(!TXBMT);
1470   3                              SPIF=0;
1471   3                              
1472   3                              if (IsPatientID)        
1473   3                              {
1474   4                                      SPI0DAT = mem[Line][i+36];
1475   4                              }
1476   3                              else                    SPI0DAT = 0x00;
1477   3                      }
1478   2      
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 25  

1479   2      
1480   2                      for (i=0 ; i < 4 ; i++) 
1481   2                      {
1482   3                              while(!TXBMT);
1483   3                              SPIF=0;
1484   3                              if (IsDateTime) 
1485   3                              {
1486   4                                      SPI0DAT = mem[Line][i+32];
1487   4                              }
1488   3                              else                    SPI0DAT = 0x00;
1489   3                      }
1490   2      
1491   2                      for(i=0;i<7;i++){
1492   3                               while(!TXBMT);
1493   3                              SPIF=0;         
1494   3                              SPI0DAT = 0x00;
1495   3                      }
1496   2      
1497   2                      for (i=0 ; i < 7; i++)
1498   2                      {
1499   3                              while(!TXBMT);
1500   3                              SPIF=0;
1501   3                              if (IsName && Line>138&&Line<330) SPI0DAT = CC[Line-138][i];
1502   3                              else            
1503   3                                      SPI0DAT = 0x00;
1504   3                      }
1505   2      
1506   2                      for (i=0 ; i < 9 ; i++) 
1507   2                              {
1508   3                              while(!TXBMT);
1509   3                              SPIF=0;
1510   3                              SPI0DAT = 0x00;
1511   3                      }
1512   2              }
1513   1      
1514   1              TPHControl();
1515   1      
1516   1      
1517   1      //      EA=1;
1518   1      //      EIE1 = tmpEIE1 ;
1519   1      //      EIE2 = tmpEIE2 ;
1520   1              FiveStep();
1521   1      }
1522          
1523          void SpacePack()
1524          {
1525   1              PaperMotorLocate();     
1526   1      }
1527          /*
1528          void EightStep()
1529          {
1530                  unsigned int d;
1531                  u15 = u15PC_PaperCKH;           
1532                  d = 1200;       while(d--);
1533                  u15 = u15PC_PaperCKL;           
1534                  d = 1200;       while(d--);
1535                  u15 = u15PC_PaperCKH;           
1536                  d = 1200;       while(d--);
1537                  u15 = u15PC_PaperCKL;           
1538                  d = 1200;       while(d--);
1539                  u15 = u15PC_PaperCKH;           
1540                  d = 1200;       while(d--);
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 26  

1541                  u15 = u15PC_PaperCKL;           
1542                  d = 1200;       while(d--);
1543                  u15 = u15PC_PaperCKH;           
1544                  d = 1200;       while(d--);
1545                  u15 = u15PC_PaperCKL;           
1546                  d = 1200;       while(d--);
1547          }*/
1548          //-----------------------------------------------------------------------------
1549          void ClosePrinter()
1550          {
1551   1              u14pb = 0xFF;
1552   1      }
1553          //===============================================
1554          
1555          void  State_Machine(void)
1556          {
1557   1         switch   (M_State)
1558   1         {
1559   2            case  ST_RX_SETUP:
1560   2               Receive_Setup();           // Receive and decode host Setup Message
1561   2               break;
1562   2            case  ST_RX_FILE:
1563   2               Receive_File();            // Receive File data from host
1564   2               break;
1565   2            case  ST_TX_ACK:
1566   2               M_State =   ST_RX_FILE;    // Ack Transmit complete, continue RX data
1567   2               break;
1568   2            case  ST_TX_FILE:             // Send file data to host
1569   2               WriteStageLength = ((BytesToWrite - BytesWrote) > MAX_BLOCK_SIZE_WRITE)? MAX_BLOCK_SIZE_WRITE:(By
             -tesToWrite - BytesWrote);
1570   2               BytesWrote  += Block_Write((unsigned char*)(ReadIndex), WriteStageLength);
1571   2               ReadIndex += WriteStageLength;
1572   2               break;
1573   2            default:
1574   2               break;
1575   2         }
1576   1      }
1577          
1578          
1579             // ISR for USB_API, run when API interrupts are enabled, and an interrupt is received
1580          void USB_API_TEST_ISR(void)interrupt    INTERRUPT_USBXpress
1581          {
1582   1         unsigned char  INTVAL   =  Get_Interrupt_Source();  // Determine type of API interrupts
1583   1         if (INTVAL  &  USB_RESET)                // Bus Reset Event, go to Wait State
1584   1         {
1585   2            M_State  =  ST_WAIT_DEV;
1586   2         }
1587   1      
1588   1         if (INTVAL  &  DEVICE_OPEN)            // Device opened on host, go to Idle
1589   1         {
1590   2            M_State  =  ST_IDLE_DEV;
1591   2         }
1592   1      
1593   1         if (INTVAL  &  TX_COMPLETE)
1594   1         {
1595   2            if (M_State == ST_RX_FILE)          // Ack Transmit complete, go to RX state
1596   2            {
1597   3               M_State  =  (ST_TX_ACK);
1598   3            }
1599   2            if (M_State == ST_TX_FILE)          // File block transmit complete, go to TX state
1600   2            {
1601   3               M_State  =  (BytesWrote == BytesToWrite) ? ST_IDLE_DEV :ST_TX_FILE;  // Go to Idle when done
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 27  

1602   3            }
1603   2         }
1604   1         if (INTVAL  &  RX_COMPLETE)            // RX Complete, go to RX Setup or RX file state
1605   1         {
1606   2            M_State  =  (M_State == ST_IDLE_DEV) ? ST_RX_SETUP : ST_RX_FILE;
1607   2         }
1608   1         if (INTVAL  &  DEVICE_CLOSE)           // Device closed, wait for re-open
1609   1         {
1610   2            M_State  =  ST_WAIT_DEV;
1611   2         }
1612   1         if (INTVAL  &  FIFO_PURGE)             // Fifo purged, go to Idle State
1613   1         {
1614   2            M_State  =  ST_IDLE_DEV;
1615   2         }
1616   1      
1617   1         State_Machine();                       // Call state machine routine
1618   1      }
1619          unsigned int IMGTAG = 0x0000;
1620          void  Receive_Setup (void)
1621          {
1622   1         char i = 0;
1623   1         BytesRead   =  Block_Read(&Buffer,  56);      // Read Setup Message
1624   1      
1625   1      
1626   1         if (Buffer[0]  == READ_MSG)         // Check See if Read File Setup
1627   1         {
1628   2                Packer.Cpu1.Command_USB   = Buffer[1];
1629   2                USB.PackType          = Buffer[2]; 
1630   2                USB.SpaceNumber       = Buffer[3];
1631   2                USB.PackNumber        = Buffer[4];
1632   2                USB.StartNumber       = Buffer[5];
1633   2                USB.TotalNumber       = Buffer[6];
1634   2                USB.PgMode            = Buffer[7];
1635   2                USB.IsShake           = Buffer[8];
1636   2                USB.Year                      = Buffer[9];
1637   2                USB.Month                     = Buffer[10];
1638   2                USB.Day                       = Buffer[11];
1639   2                USB.IsAutoCut = Buffer[12];
1640   2                USB.IsPrintNumber     = Buffer[13];
1641   2                IsDrugReady           = Buffer[14];
1642   2            Buffer[0]   =  Mark;            // Send host size of transfer message
1643   2                Buffer[1]       =  USB.Command;
1644   2            Buffer[2]   =  Packer.Cpu1.State;//Read_S; //LengthFile[1];
1645   2            Buffer[3]   =  Packer.Cpu1.NowNumber;//Signs;  //LengthFile[0];
1646   2                Buffer[4]       =  Packer.Cpu1.PowderLocation;//Packer.Cpu1.PowderLocation;
1647   2                Buffer[5]       =  Packer.Cpu1.Thermometer;
1648   2                Buffer[6]       =  Packer.Cpu1.ImageNumber;
1649   2                Buffer[7]   =  Packer.Cpu1.Message;
1650   2                Buffer[8]       =  Packer.ErrorCode;
1651   2                Buffer[9]       =  Read_S;
1652   2                Buffer[10]  =  0xFF;    
1653   2            BytesWrote  =  Block_Write((unsigned char*)&Buffer,   15);
1654   2                M_State =  ST_IDLE_DEV; 
1655   2                Read_S+=1;
1656   2                Mark = 0xFF;
1657   2      
1658   2         }
1659   1         else if(Buffer[0] == WRITE_DAT)
1660   1         {
1661   2                      for(i=1;i<56;i++)
1662   2                      {
1663   3                              mem[IMGSer][IMGTAG][i-1] = Buffer[i];
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 28  

1664   3                      }
1665   2                      IMGTAG ++;
1666   2                      if(IMGTAG >= 520)
1667   2                      {
1668   3                              USB.Command = USBCommand_Idel;
1669   3                              IsUSBRxReady = 1;
1670   3                              IMGTAG = 0;
1671   3                              if(IMGSer == 0)
1672   3                                      IMGSer = 1;
1673   3                              else
1674   3                                      IMGSer = 0;
1675   3                      }
1676   2                      else
1677   2                              USB.Command = USBCommand_MemroyWrite;
1678   2                      Buffer[1] = USB.Command;
1679   2                      BytesWrote  =  Block_Write((unsigned char*)&Buffer,   15);
1680   2                      M_State =  ST_IDLE_DEV;                 
1681   2         }
1682   1         else if(Buffer[0] == CommandACK)
1683   1         {
1684   2                      USB.Command = USBCommand_Idel;
1685   2                      Buffer[1] = USB.Command;
1686   2                      BytesWrote  =  Block_Write((unsigned char*)&Buffer,   15);
1687   2                      M_State =  ST_IDLE_DEV;  
1688   2         }
1689   1      }
1690          
1691          //===============================================
1692          //-----------------------------------------------------------------------------
1693          void PowderToLeft()
1694          {
1695   1              Packer.Cpu1.State = Cpu1State_PowderLocating;
1696   1              Powder(MotorLeft,PowderPWM);    
1697   1      
1698   1              errorTime = Time_PowderLSW ;
1699   1      
1700   1              while (PowderLSW)
1701   1              {
1702   2      //              Delay(1000);
1703   2      //              Delay(1000);
1704   2                      i_Delay(Time_PSDelay);
1705   2                      i_Delay(Time_PSDelay);
1706   2                      CheckErrorCode(ErrorCode_Powder);
1707   2              }
1708   1              Powder(MotorStop,0xFF);
1709   1              Delay(1000);
1710   1              Counter = Ini_Location;
1711   1              CounterTag = PowderCounterPS;
1712   1      }
1713          //-----------------------------------------------------------------------------
1714          void PowderToRight()
1715          {
1716   1              Packer.Cpu1.State = Cpu1State_PowderLocating;
1717   1              Powder(MotorRight,PowderPWM);
1718   1              
1719   1              errorTime = Time_PowderRSW ;
1720   1      
1721   1              while (PowderRSW)
1722   1              {
1723   2      //              Delay(1000);
1724   2      //              Delay(1000);
1725   2                      i_Delay(Time_PSDelay);
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 29  

1726   2                      i_Delay(Time_PSDelay);
1727   2                      CheckErrorCode(ErrorCode_Powder);
1728   2              }
1729   1              Powder(MotorStop,0xFF);
1730   1              Delay(1000);
1731   1      }
1732          void DrugToRight()
1733          {
1734   1              PCA0CPH2 = 0x40;
1735   1              u14 = u14PC_DrugRight;
1736   1              Delay(20);
1737   1      
1738   1              errorTime = Time_DrugRSW ;
1739   1      
1740   1              while(DrugRSW==1) 
1741   1              {
1742   2                      i_Delay(Time_PSDelay);
1743   2                      CheckErrorCode(ErrorCode_Drug);
1744   2              } 
1745   1      
1746   1              u14 = u14PC_DrugStop;
1747   1              Delay(800);
1748   1      }
1749          //-----------------------------------------------------------------------------
1750          void CloseLeave()
1751          {
1752   1              Powder(MotorLeft,PowderPWM);
1753   1              while(PowderCounterPS ==1 ) 
1754   1              {
1755   2                      if (PowderLSW ==0) 
1756   2                      {
1757   3                      Powder(MotorStop,0xFF);
1758   3                      Delay(1000);
1759   3                      return;
1760   3                      }
1761   2      
1762   2              }
1763   1              while(PowderCounterPS ==0 ) 
1764   1              {
1765   2                      if (PowderLSW ==0) 
1766   2                      {
1767   3                      Powder(MotorStop,0xFF);
1768   3                      Delay(1000);
1769   3                      return;
1770   3                      }
1771   2      
1772   2              }
1773   1      
1774   1              Powder(MotorStop,0xFF);
1775   1              Powder(MotorLeft,PowderPWM);
1776   1              while(PowderCounterPS ==1) 
1777   1              {
1778   2                      if (PowderLSW ==0) 
1779   2                      {
1780   3                      Powder(MotorStop,0xFF);
1781   3                      Delay(1000);
1782   3                      return;
1783   3                      }
1784   2      
1785   2              }
1786   1              while(PowderCounterPS ==0) 
1787   1              {
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 30  

1788   2                      if (PowderLSW ==0) 
1789   2                      {
1790   3                      Powder(MotorStop,0xFF);
1791   3                      Delay(1000);
1792   3                      return;
1793   3                      }
1794   2              }
1795   1      
1796   1              Powder(MotorStop,0xFF);
1797   1              Delay(1000);
1798   1      
1799   1              Powder(MotorRight,PowderPWM);
1800   1              while(PowderCounterPS ==1) ;
1801   1              while(PowderCounterPS ==0) ;
1802   1              Powder(MotorStop,0xFF);
1803   1              Powder(MotorRight,PowderPWM);
1804   1              while(PowderCounterPS ==1) ;
1805   1              while(PowderCounterPS ==0) ;
1806   1              Powder(MotorStop,0xFF);
1807   1      
1808   1              IsFR =0;
1809   1              Delay(1000);
1810   1      }
1811          //-----------------------------------------------------------------------------
1812          void PowderNumber()
1813          {
1814   1      
1815   1              unsigned char s=0;
1816   1              Packer.Cpu1.PowderLocation =0;          
1817   1              Packer.Cpu1.State = Cpu1State_PowderLocating;
1818   1              AccessCpu0(Cpu0Command_ShowPowderLocating);     
1819   1              Packer.Cpu1.Message = Message_PowderLocating;           
1820   1              //AccessUSB(USBCommand_Busy);   
1821   1      
1822   1              if (PaperMotorPS != 1)
1823   1              {
1824   2                      PaperMotorLocate();             
1825   2              }
1826   1      
1827   1      
1828   1              PowderToLeft();                                         
1829   1      
1830   1      
1831   1              PowderCounterPS_LastState = PowderCounterPS ;
1832   1              PowderLocationCounter = 0;
1833   1              PowderLocate();                                         
1834   1      }
1835          
1836          //-----------------------------------------------------------------------------
1837          void Carbon(bit bSW){
1838   1              CarbonBTW = bSW;
1839   1              PCA0CPH1  = 0xA0;
1840   1              if (bSW)
1841   1              {
1842   2                      u14 = u14PC_CarbonStart ;
1843   2      
1844   2              }
1845   1              else
1846   1              {
1847   2                      u14 = u14PC_CarbonStop ;
1848   2              }
1849   1      }
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 31  

1850          //-----------------------------------------------------------------------------
1851          
1852          void PaperMotorForward()
1853          {
1854   1              unsigned int i;
1855   1              u15 = u15PC_PaperCW ;
1856   1              Delay(10);
1857   1              u15 = u15PC_PaperEnable;
1858   1              Delay(10);
1859   1              for (i=0 ; i < 80 ; i++)
1860   1              {
1861   2                      OneStep(800);   
1862   2              }
1863   1      
1864   1              u15 = u15PC_PaperDisable;
1865   1      }
1866          //-----------------------------------------------------------------------------
1867          void PaperMotorReverse()
1868          {
1869   1              unsigned int i;
1870   1              u15 = u15PC_PaperCCW ;
1871   1              Delay(10);
1872   1              u15 = u15PC_PaperEnable;
1873   1              Delay(10);
1874   1              for (i=0 ; i < 80 ; i++)
1875   1              {
1876   2                      OneStep(800);   
1877   2              }
1878   1              u15 = u15PC_PaperDisable;
1879   1      }
1880          //-----------------------------------------------------------------------------
1881          void PaperMotorLocate()
1882          {
1883   1              unsigned char i;
1884   1              u15 = u15PC_PaperCW ;
1885   1              Delay(10);
1886   1              u15 = u15PC_PaperEnable;
1887   1              Delay(10);
1888   1              for (i=0;i<Packer.PgMode[USB.PgMode].Length;i++)
1889   1                      OneStep(Time_PaperMotorDelay);  
1890   1              u15 = u15PC_PaperDisable;
1891   1      }
1892          //-----------------------------------------------------------------------------
1893          void Delay(unsigned int DTime)
1894          {
1895   1      //      i=i<<1;
1896   1              while(DTime--)
1897   1              {
1898   2                      unsigned char DTime2=100;       // 1mSec
1899   2                      while(DTime2--);
1900   2      
1901   2              }
1902   1      }
1903          void i_Delay(unsigned int DTime)
1904          {
1905   1      //      i=i<<1;
1906   1              while(DTime--)
1907   1              {
1908   2                      unsigned char DTime2=100;       // 1mSec
1909   2                      while(DTime2--);
1910   2      
1911   2              }
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 32  

1912   1      }
1913          
1914          //-----------------------------------------------------------------------------
1915          void PCA0_Init (void)
1916          {
1917   1         // Configure PCA time base; overflow interrupt disabled
1918   1         PCA0CN = 0x40;                      // Stop counter; clear all flags
1919   1         PCA0MD = 0x00;                      // Use SYSCLK as time base
1920   1      
1921   1         PCA0CPM0 = 0x42;                    // Module 0 = 8-bit PWM mode
1922   1         PCA0CPM1 = 0x42;
1923   1         PCA0CPM2 = 0x42;
1924   1         // Configure initial PWM duty cycle = 50%
1925   1         PCA0CPH0 = 0x60;
1926   1         PCA0CPH1 = 0x40;
1927   1         PCA0CPH2 = 0x40;
1928   1         // Start PCA counter
1929   1         CR = 1;
1930   1      }
1931          //-----------------------------------------------------------------------------
1932          void OSCILLATOR_Init (void)
1933          {
1934   1         OSCICN = 0x83;                      // Set internal oscillator to run
1935   1                                             // at its maximum frequency
1936   1      
1937   1         CLKSEL = 0x00;                      // Select the internal osc. as
1938   1                                             // the SYSCLK source
1939   1         OSCICL = 0x10;
1940   1         CLKSEL |= 0x03;
1941   1         RSTSRC   |= 0x02;
1942   1      }
1943          //-----------------------------------------------------------------------------
1944          void OneStep(unsigned int time)
1945          {
1946   1              unsigned int d ;
1947   1      
1948   1              u15 = u15PC_PaperCKH;           
1949   1              d = time;       while(d--);
1950   1              u15 = u15PC_PaperCKL;           
1951   1              d = time;       while(d--);
1952   1              u15 = u15PC_PaperCKH;           
1953   1              d = time;       while(d--);
1954   1              u15 = u15PC_PaperCKL;           
1955   1              d = time;       while(d--);
1956   1              u15 = u15PC_PaperCKH;           
1957   1              d = time;       while(d--);
1958   1              u15 = u15PC_PaperCKL;           
1959   1              d = time;       while(d--);
1960   1      }
1961          
1962          //-----------------------------------------------------------------------------
1963          void SPI_Init()
1964          {
1965   1          SPI0CFG   = 0x40;
1966   1          SPI0CN    = 0x01;
1967   1              SPI0CKR   = 0x07;
1968   1      }
1969          void Timer0_Init(void)
1970          {
1971   1         TH0 = 0x30;//-31.25;           // Init Timer0 High register
1972   1         TL0 = TH0;                          // Set the intial Timer0 value
1973   1         TH1 = 0x30;
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 33  

1974   1         TL1 = TH1;
1975   1         TMOD = 0x02;                        // Timer0 in 8-bit reload mode
1976   1         CKCON = 0x22;                       // Timer0 uses a 1:48 prescaler
1977   1         ET0 = 1;                              // Timer0 interrupt enabled
1978   1         ET1 = 1;
1979   1         TCON = 0x50;                        // Timer0 ON
1980   1      }
1981          void Timer1_ISR (void) interrupt 3
1982          {
1983   1              TR1 = 0;
1984   1              /*
1985   1              if(Packer.Cpu1.VacuumType == VacuumType_HighSpeed || VacuumSW)
1986   1                      u15pc &= 0xFE;
1987   1              else if(Packer.Cpu1.VacuumType == VacuumType_LowSpeed)
1988   1                      u15pc &= 0xFD;
1989   1              else if(Packer.Cpu1.VacuumType == VacuumType_Stop || !VacuumSW)
1990   1                      u15pc |= 0x03;*/
1991   1              TempPWM ++;
1992   1              if(CarbonBTW)
1993   1              {
1994   2                      if(CarbonHall != CarbonTag)
1995   2                      {
1996   3                              CarbonTag = CarbonHall;
1997   3                              CarbonError = 0;
1998   3                      }
1999   2                      else
2000   2                      {                       
2001   3                              if(CarbonError ++ > 500)
2002   3                              {
2003   4                                      IsCarbonEntry = 1;
2004   4                                      CarbonError = 0;
2005   4                              }
2006   3                      }
2007   2              }
2008   1              AD0BUSY = 1;
2009   1              TR1 = 1;
2010   1      }
2011          void Timer0_ISR (void) interrupt 1
2012          {
2013   1              TR0=0;
2014   1      //      P2 &= 0x7F;
2015   1              _Sel = 1;
2016   1              switch(u14){
2017   2                      case u14PC_CarbonStop:
2018   2                              u14pc &= 0xFE;
2019   2                              break;
2020   2                      case u14PC_CarbonStart:
2021   2                              u14pc |= 0x01;
2022   2                              break;
2023   2                      case u14PC_PowderCoverStop:
2024   2                              u14pc &= 0xFD;
2025   2                              break;
2026   2                      case u14PC_PowderCoverStart:
2027   2                              u14pc |= 0x02;
2028   2                              break;
2029   2                      case u14PC_DrugCoverStop:
2030   2                              u14pc &= 0xFB;
2031   2                              break;
2032   2                      case u14PC_DrugCoverStart:
2033   2                              u14pc |= 0x04;
2034   2                              break;
2035   2                      case u14PC_PresureStop:
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 34  

2036   2                              u14pc &= 0xF7;
2037   2                              break;
2038   2                      case u14PC_PresureStart:
2039   2                              u14pc |= 0x08;
2040   2                              break;
2041   2                      case u14PC_PowderRight:
2042   2                              //PCA0CPH0=0x60;
2043   2                              u14pc &= 0xEF;
2044   2                              break;
2045   2                      case u14PC_PowderLeft:
2046   2                              //PCA0CPH0=0x60;
2047   2                              u14pc |= 0x10;
2048   2                              break;
2049   2                      case u14PC_PowderStop:
2050   2                              u14pc &= 0xDF;
2051   2                              break;
2052   2                      case u14PC_PowderStart:
2053   2                              u14pc |= 0x20;
2054   2                              break;
2055   2                      case u14PC_DrugRight:
2056   2                              u14pc &= 0xBF;
2057   2                              break;
2058   2                      case u14PC_DrugLeft:
2059   2                              u14pc |= 0x40;
2060   2                              break;
2061   2                      case u14PC_DrugStop:
2062   2                              u14pc &= 0x7F;
2063   2                              break;
2064   2                      case u14PC_DrugStart:
2065   2                              u14pc |= 0x80;
2066   2                              break;
2067   2              }
2068   1              switch(u15){
2069   2                      case u15PC_PaperCKL:
2070   2                              u15pc &= 0xEF;
2071   2                              break;
2072   2                      case u15PC_PaperCKH:
2073   2                              u15pc |= 0x10;
2074   2                              break;
2075   2                      case u15PC_PaperCW:
2076   2                              u15pc &= 0xDF;
2077   2                              break;
2078   2                      case u15PC_PaperCCW:
2079   2                              u15pc |= 0x20;
2080   2                              break;
2081   2                      case u15PC_PaperEnable:
2082   2                              u15pc &= 0xBF;
2083   2                              break;
2084   2                      case u15PC_PaperDisable:
2085   2                              u15pc |= 0x40;
2086   2                              break;
2087   2                      case u15PC_PaperPressON:
2088   2                              u15pc &= 0xFD;
2089   2                              break;
2090   2                      case u15PC_PaperPressOFF:
2091   2                              u15pc |= 0x03;
2092   2                              break;
2093   2                      case u15PC_SharkerON:
2094   2                              u15pc |= 0x08;
2095   2                              break;
2096   2                      case u15PC_SharkerOFF:
2097   2                              u15pc &= 0xF7;
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 35  

2098   2                              break;
2099   2      
2100   2              }
2101   1              if(TempPWM ++ > 0XFE)
2102   1                      TempPWM = 0;
2103   1              if(TempPWM < Packer.Cpu1.HeaterPWM)
2104   1              {
2105   2                      u15pc &= 0xFB;
2106   2              }
2107   1              else 
2108   1              {
2109   2                      u15pc |= 0x04;  
2110   2              }
2111   1      //      _u14pb(u14pb);
2112   1              _u14pc(u14pc);
2113   1              _u15pc(u15pc);
2114   1              _u14PAR();
2115   1              _u15PAR();
2116   1              /*
2117   1              if(PaperLPS == !PaperLSign && PaperLPS == 0)
2118   1                      PaperLTension ++;       
2119   1          if(PaperRPS == !PaperRSign && PaperRPS == 0)
2120   1                      PaperRTension ++;
2121   1              PaperLSign = PaperLPS;  
2122   1              PaperRSign = PaperRPS;*/
2123   1              _u15PBR();
2124   1      
2125   1              _Sel = 0;
2126   1              TR0=1;
2127   1      
2128   1      }
2129          
2130          //-----------------------------------------------------------------------------
2131          void PowderLocate()
2132          {
2133   1              Packer.Cpu1.State = Cpu1State_PowderLocating;
2134   1              AccessCpu0(Cpu0Command_ShowPowderLocating);                     
2135   1              Packer.Cpu1.Message = Message_PowderLocating;
2136   1              while(1)
2137   1              {
2138   2                      if(!PowderLSW)
2139   2                      {
2140   3                              Powder(MotorStop,0xFF);
2141   3                              Delay(1000);
2142   3                              CursorLocation = CursorRightEntry;
2143   3                              Dir = 1;
2144   3                              Powder(MotorRight,PowderPWM);
2145   3                              //Delay(1000);
2146   3                              while(!PowderLSW);
2147   3                      }
2148   2                      else if(!PowderRSW)
2149   2                      {
2150   3                              Powder(MotorStop,0xFF);
2151   3                              Delay(1000);
2152   3                              //Counter = 90;
2153   3                              CursorLocation = CursorLeftEntry;
2154   3                              
2155   3                              Powder(MotorLeft,PowderPWM);
2156   3                              //Delay(1000);
2157   3                              while(!PowderRSW);
2158   3                      }
2159   2                      if ( CursorLocation == CursorLeftEntry) //1
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 36  

2160   2                      {
2161   3                              Powder(MotorLeft,PowderPWM);
2162   3                              Dir = 0;
2163   3                      }
2164   2                      else if ( CursorLocation == CursorRightEntry)   //1
2165   2                      {
2166   3                              Powder(MotorRight,PowderPWM);
2167   3                              Dir = 1;
2168   3                      }
2169   2                      else if ( CursorLocation == CursorLeftHall )    //2
2170   2                      {
2171   3                              unsigned long l=0x60000;
2172   3                              Powder(MotorStop,0xFF);
2173   3                              Delay(5000);
2174   3                              Dir = 1;
2175   3                              Powder(MotorRight,0xA0);                
2176   3                              while (CursorLocation != CursorRightHall)
2177   3                              {                               
2178   4                                      if (l-- ==0 || !PowderRSW)
2179   4                                      {       
2180   5                                              Powder(MotorStop,0xFF);
2181   5                                              Delay(5000);
2182   5                                              CounterTag = PowderCounterPS;
2183   5                                              break;
2184   5                                      }
2185   4                              }
2186   3                              if (CursorLocation == CursorRightHall){
2187   4                                      break;
2188   4                              }
2189   3                      }
2190   2      
2191   2              }
2192   1              Powder(MotorStop,0xFF);
2193   1              Delay(6000);
2194   1              Packer.Cpu1.PowderLocation = Counter/2;
2195   1              CounterTag = PowderCounterPS;
2196   1              if(!PowderCounterPS == 0){
2197   2                      Packer.ErrorCode = ErrorCode_Powder ;
2198   2                      while(RHall == 0){
2199   3                              Packer.Cpu1.State = Cpu1State_Error ;
2200   3                              AccessCpu0(Cpu0Command_ShowCPU1ErrorCode);                                              
2201   3                              Delay(800);
2202   3                      }
2203   2                      Delay(1000);
2204   2                      Packer.ErrorCode = ErrorCode_NoError ;
2205   2                      PowderLocate();
2206   2              }
2207   1              Counter = Packer.Cpu1.PowderLocation * 2;
2208   1              Packer.Cpu1.State = Cpu1State_Idel ;
2209   1              AccessCpu0(Cpu0Command_ShowSystemReady);
2210   1              Packer.Cpu1.Message = Message_SystemReady ;
2211   1      }
2212          
2213          
2214          //================== ADC0 P0.4     =======================================
2215          void ADC0_Init (void)
2216          {
2217   1         REF0CN = 0x0B;                      // Enable on-chip VREF and buffer
2218   1      
2219   1         AMX0P = 0x13;                       // ADC0 positive input = P0.4
2220   1         AMX0N = 0x1F;                       // ADC0 negative input = GND
2221   1                                             // i.e., single ended mode
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 37  

2222   1      
2223   1         ADC0CF = 0xF8;
2224   1      
2225   1         EIE1 |= 0x08;                       // enable ADC0 conversion complete int.
2226   1      
2227   1         AD0EN = 1;                          // enable ADC0
2228   1         AD0BUSY = 1;
2229   1      }
2230          unsigned int meanCount = 100; // Total number of bytes to read from host
2231          unsigned long accumulator = 0;     // Accumulator for averaging
2232          //unsigned long  mV;    // Measured voltage in mV
2233          unsigned int Tempture;
2234          //unsigned int result=0;
2235          //unsigned int ADC0ADD= 0;
2236          void ADC0_ISR (void) interrupt 10
2237          {
2238   1         AD0INT = 0;                               // Clear ADC0 conv. complete flag
2239   1      
2240   1         accumulator += ADC0L;
2241   1         accumulator = accumulator + ((ADC0H & 0x03) <<8);
2242   1      //   accumulator += ADC0;
2243   1         meanCount --;
2244   1      
2245   1      //      ADC0ADD = ADC0;
2246   1      
2247   1         if(meanCount==0)
2248   1         {  
2249   2            meanCount = 300; 
2250   2                Tempture = accumulator /meanCount / 5.265 + 25 ; 
2251   2                accumulator=0;
2252   2         }
2253   1      
2254   1      }
2255          //-----------------------------------------------------------------------------
2256          void ShowPackType()
2257          {
2258   1              if (Packer.Cpu0.PackType == PackType_Powder)
2259   1              {
2260   2                      AccessCpu0(Cpu0Command_ShowPackPowder);
2261   2                      Packer.Cpu1.Message = Message_PackPowder;
2262   2              }               
2263   1              else if (Packer.Cpu0.PackType == PackType_Drug)
2264   1              {
2265   2                      AccessCpu0(Cpu0Command_ShowPackDrug);
2266   2                      Packer.Cpu1.Message = Message_PackDrug;
2267   2              }
2268   1              else if (Packer.Cpu0.PackType == PackType_Mix)
2269   1              {
2270   2                      AccessCpu0(Cpu0Command_ShowPackMix);
2271   2                      Packer.Cpu1.Message = Message_PackMix;
2272   2              }
2273   1      }
2274          //-----------------------------------------------------------------------------
2275          void ShowPackTypeUSB()
2276          {
2277   1              if (USB.PackType == PackType_Powder)
2278   1              {
2279   2                      AccessCpu0(Cpu0Command_ShowPackPowder);
2280   2                      Packer.Cpu1.Message = Message_PackPowder;
2281   2              }               
2282   1              else if (USB.PackType == PackType_Drug)
2283   1              {
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 38  

2284   2                      AccessCpu0(Cpu0Command_ShowPackDrug);
2285   2                      Packer.Cpu1.Message = Message_PackDrug;
2286   2              }
2287   1              else if (USB.PackType == PackType_Mix)
2288   1              {
2289   2                      AccessCpu0(Cpu0Command_ShowPackMix);
2290   2                      Packer.Cpu1.Message = Message_PackMix;
2291   2              }
2292   1      }
2293          //============================================================
2294          void UART1_Init (void){
2295   1      /*
2296   1              SBRLL1    = 0x3C;
2297   1          SBRLH1    = 0xF6;
2298   1          SCON1     = 0x10;           //埰勍UART1諉彶
2299   1          SMOD1     = 0x0E;
2300   1          SBCON1    = 0x43;  
2301   1      */
2302   1              SBRLL1    = 0x3C;
2303   1          SBRLH1    = 0xF6;
2304   1          SCON1     = 0x10;           //埰勍UART1諉彶
2305   1          SMOD1     = 0x0C;
2306   1          SBCON1    = 0x43; 
2307   1      }
2308          //-----------------------------------------------------------------------------
2309          
2310          void putchar(unsigned char cData)
2311          {
2312   1              unsigned int i=10000;
2313   1              while( (SCON1 & 0x20) ==0) ;
2314   1              SBUF1 = cData;
2315   1              if(cData == Packer.ErrorCode){
2316   2                      EIE2 |= 0x02;
2317   2                      SCON1&=0x3F;
2318   2              }
2319   1              while(i--);     
2320   1      }
2321          
2322          //-----------------------------------------------------------------------------
2323          char _getkey ()  {
2324   1          char c;
2325   1          while (!(SCON1 & 0x01));           // wait until UART1 receives a character
2326   1          c = SBUF1;                         // save character to local variable
2327   1          SCON1 &= ~0x01;                    // clear UART1 receive interrupt flag
2328   1          return (c);                        // return value received through UART1
2329   1      }
2330          //-----------------------------------------------------------------------------
2331          void DisableAllDriver()
2332          {
2333   1      //      Packer.Cpu1.HeaterPWM = TempPWM_OFF ;
2334   1              u14 = u14PC_CarbonStop ;
2335   1      //      IsCarbonStart =0;
2336   1      
2337   1              u14 = u14PC_PowderCoverStop ;
2338   1              u14 = u14PC_DrugCoverStop ;
2339   1      
2340   1              u14 = u14PC_PresureStop ;
2341   1              u14 = u14PC_PowderStop ;
2342   1              u14 = u14PC_DrugStop ;
2343   1      
2344   1              u15 = u15PC_PaperPressOFF ;
2345   1              Delay(10);
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 39  

2346   1      //      u15 = u15PC_HeaterControlL      ;
2347   1              u15 = u15PC_SharkerOFF ;
2348   1              Delay(10);
2349   1              u15 = u15PC_PaperResetH ;
2350   1              Delay(10);
2351   1              u15 = u15PC_PaperDisable;
2352   1      }
2353          //-----------------------------------------------------------------------------
2354          void RxPackInfo()
2355          {
2356   1              xdata   byte *i,aa[39],j=0;
2357   1      
2358   1              EIE2 &= ~0x02;
2359   1      
2360   1              for ( i = &Packer.Cpu0.PackType ; i <= (&Packer.Cpu0.PackType +38); i ++)
2361   1              {       
2362   2                      while ( (SCON1 & 0x01) == 0);
2363   2                      SCON1 &= (~0x01);       // RI=0
2364   2                      *(i) = SBUF1;
2365   2                      aa[j] = *i;
2366   2                      j++ ;
2367   2              }
2368   1              BitPackParameter = Packer.Cpu0.BitPackParameter ;
2369   1              EIE2 |= 0x02;
2370   1      }
2371          //-----------------------------------------------------------------------------
2372          
2373          void AccessCPU0(ECpu1Command Command)
2374          {
2375   1              unsigned int i=0;
2376   1      //      Packer.Cpu1.PowderLocation = (PowderLocationCounter ) /2;
2377   1      //      Packer.Cpu1.Thermometer = Tempture;                                                              
2378   1              putchar(UART_Mark) ;
2379   1      
2380   1              putchar(Command);
2381   1      
2382   1              putchar(Packer.Cpu1.State);
2383   1      
2384   1              putchar(Packer.Cpu1.NowNumber);
2385   1      
2386   1              putchar(Packer.Cpu1.PowderLocation);
2387   1      
2388   1              putchar(Packer.Cpu1.Thermometer++);
2389   1      
2390   1              putchar(Packer.ErrorCode);
2391   1                      
2392   1      
2393   1              IsRxCommand =0;
2394   1              while(!IsRxCommand) 
2395   1              {
2396   2                      if (i++ >= 40000)       
2397   2                      {
2398   3                              i=0;
2399   3                              Pointer_Packer = &Packer.UART_Mark;
2400   3                              Packer.UART_Mark = UART_NoMark ;
2401   3                              Cpu1CommandIdel();
2402   3                              return;
2403   3                      }
2404   2              }
2405   1      
2406   1              if (Command == Cpu0Command_TxPackInfo)
2407   1              {
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 40  

2408   2                      RxPackInfo();
2409   2              }
2410   1              else 
2411   1              {
2412   2                      Delay(50);
2413   2              }
2414   1      
2415   1              Pointer_Packer = &Packer.UART_Mark ;
2416   1      
2417   1              if (Packer.Cpu0.State == Cpu0State_SettingMode)
2418   1              {
2419   2                      Delay(1000);
2420   2              }
2421   1              else if (Packer.Cpu0.State == Cpu0State_PackingMode)
2422   1              {
2423   2      //              if (Packer.UART_Mark == UART_Mark)
2424   2                      {
2425   3                              if (Packer.Cpu1.Command_UART == Cpu1Command_PackPause)
2426   3                              {
2427   4                                      IsPackPause = 1;
2428   4                                      Cpu1CommandIdel();
2429   4                              }
2430   3                              else if (Packer.Cpu1.Command_UART == Cpu1Command_PackStop ||
2431   3                                               Packer.Cpu1.Command_UART == Cpu1Command_PackContinue )
2432   3                              {
2433   4                                      IsPackPause = 0;
2434   4                              }
2435   3                              else if (Packer.Cpu1.Command_UART == Cpu1Command_Again)
2436   3                              {
2437   4                                      IsAgain = 1;
2438   4                              }
2439   3                      }
2440   2              }
2441   1      }
2442          //-----------------------------------------------------------------------------
2443          byte Cpu1Command()
2444          {
2445   1              if (Packer.Cpu1.Command_UART != Cpu1Command_Idel )
2446   1              {
2447   2                      return Packer.Cpu1.Command_UART;
2448   2              }
2449   1              else 
2450   1              {
2451   2                      return Packer.Cpu1.Command_USB;
2452   2              }
2453   1      }
2454          //-----------------------------------------------------------------------------
2455          void Cpu1CommandIdel()
2456          {
2457   1              Packer.Cpu1.Command_UART = Cpu1Command_Idel ;
2458   1              Packer.Cpu1.Command_USB  = Cpu1Command_Idel ;
2459   1      }
2460          //-----------------------------------------------------------------------------
2461          
2462          void UART1_ISR(void)   interrupt 16 
2463          {
2464   1              EIE2 &= ~0x02;
2465   1              if (SCON1 & 0x02)               // TI1
2466   1              {
2467   2                      SCON1 &= (~0x02);
2468   2              }
2469   1      
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 41  

2470   1              if (SCON1 & 0x01 )              // RI1
2471   1              {
2472   2                      SCON1 &= (~0x01);
2473   2                      *(Pointer_Packer) = SBUF1;
2474   2                      if(Pointer_Packer == &Packer.UART_Mark)
2475   2                      {
2476   3                              if (Packer.UART_Mark == UART_Mark)
2477   3                              {
2478   4                                      Packer.UART_Mark = UART_NoMark ;
2479   4                                      Pointer_Packer = & Packer.Cpu1.Command_UART ;
2480   4      
2481   4                                      RxTimeOutCount =0;
2482   4                                      TR2 =1;
2483   4                              }
2484   3                              else
2485   3                              {       
2486   4                                      Pointer_Packer = &Packer.UART_Mark;
2487   4                              }                       
2488   3                      }
2489   2                      else if(Pointer_Packer == & Packer.Cpu1.Command_UART)
2490   2                      {
2491   3                              Pointer_Packer = &Packer.Cpu0.State ;
2492   3                      }
2493   2                      else if(Pointer_Packer == &Packer.Cpu0.State)
2494   2                      {
2495   3                              Pointer_Packer = &Packer.UART_Mark;     
2496   3                              IsRxCommand = 1;
2497   3                              RxTimeOutCount =0;
2498   3                              TR2 =0; 
2499   3                      }
2500   2                      else 
2501   2                      {
2502   3                              Pointer_Packer = &Packer.UART_Mark;
2503   3      
2504   3                      }
2505   2      
2506   2              }
2507   1      
2508   1              EIE2 |= 0x02;
2509   1      }
2510          //-----------------------------------------------------------------------------
2511          void PowderCoverOpen()
2512          {
2513   1              unsigned char i;
2514   1              i = Packer.Cpu1.PowderCoverOpenNumber ;
2515   1              if (i>4) i=2;
2516   1      
2517   1              u14 = u14PC_PowderCoverStart ;
2518   1              Delay(50);
2519   1              while(i--)
2520   1              {
2521   2                      errorTime = Time_PowderCoverPS ;
2522   2                      do 
2523   2                      {
2524   3                              i_Delay(Time_PSDelay);
2525   3                              CheckErrorCode(ErrorCode_PowderCover);
2526   3                      } while(PowderCoverPS==1) ;
2527   2      
2528   2                      errorTime = Time_PowderCoverPS ;
2529   2                      do 
2530   2                      {
2531   3                              i_Delay(Time_PSDelay);
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 42  

2532   3                              CheckErrorCode(ErrorCode_PowderCover);
2533   3                      } while(PowderCoverPS==0) ;
2534   2              }
2535   1              u14 = u14PC_PowderCoverStop ;
2536   1              Delay(800);
2537   1      }
2538          //-----------------------------------------------------------------------------
2539          void CheckErrorCode(EErrorCode ECode)
2540          {
2541   1              if (errorTime-- == 0)
2542   1              {
2543   2                      DisableAllDriver();
2544   2      
2545   2                      Packer.ErrorCode = ECode ;
2546   2                      while(1)
2547   2                      {
2548   3                              Packer.Cpu1.State = Cpu1State_Error ;
2549   3                              AccessCpu0(Cpu0Command_ShowCPU1ErrorCode);      
2550   3                              //AccessUSB(USBCommand_Busy);                                   
2551   3                              Delay(800);
2552   3                      }
2553   2              }
2554   1      }
2555          //-----------------------------------------------------------------------------
2556          void AutoClear()
2557          {
2558   1              Packer.Cpu1.PowderLocation =0;  
2559   1              Packer.Cpu1.State = Cpu1State_Clearing;
2560   1      
2561   1              AccessCpu0(Cpu0Command_ShowClearing);                   
2562   1      //      AccessUSB(USBCommand_Busy);     
2563   1      
2564   1              if (PaperMotorPS != 1)
2565   1              {
2566   2                      PaperMotorLocate();             
2567   2              }
2568   1              Packer.Cpu1.VacuumType = VacuumType_HighSpeed ;
2569   1              Delay(10);
2570   1              PowderToLeft();
2571   1      
2572   1      
2573   1              CursorLocation = CursorRightEntry ;
2574   1              PowderCounterPS_LastState = PowderCounterPS ;
2575   1      
2576   1              PowderLocationCounter = 0;
2577   1              PowderLocate();
2578   1      
2579   1              Packer.Cpu1.VacuumType = VacuumType_Stop ;
2580   1              Delay(10);
2581   1              Packer.Cpu1.State = Cpu1State_Idel ;
2582   1              AccessCpu0(Cpu0Command_ShowSystemReady);
2583   1      //      AccessUSB(USBCommand_Idel);     
2584   1      }
2585          //-----------------------------------------------------------------------------
2586          
2587          void HeadWithPrint()
2588          {
2589   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8558    ----
C51 COMPILER V9.51   PRINTER                                                               09/18/2018 22:25:38 PAGE 43  

   CONSTANT SIZE    =  15108    ----
   XDATA SIZE       =  57215      43
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45      51
   IDATA SIZE       =     63    ----
   BIT SIZE         =     20       7
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
