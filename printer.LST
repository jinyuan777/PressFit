C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE PRINTER
OBJECT MODULE PLACED IN printer.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe printer.c DB OE BR INCDIR(c:\SiLabs\MCU\Inc)

line level    source

   1          #include <C8051F340.h>
   2          #include <communication2.h>
   3          #include <CPU1X.h>
   4          #include <intrins.h>
   5          #include <A_FORM.c>
   6          #include <format.c>
   7          #include <format1.c>
   8          //============================================
   9          #include "USB_API.h"
  10          #include "compiler_defs.h"
  11          #define INTERRUPT_USBXpress 17
  12          #define U32 unsigned int 
  13          xdata TPacker Packer _at_ 0x0000 ;
  14          xdata TUSB      USB;
  15          //............................
  16          
  17          SEGMENT_VARIABLE(WriteStageLength, U16, SEG_DATA); //  Current write transfer stage length
  18          SEGMENT_VARIABLE(BytesRead, U16, SEG_DATA);  // Number of Bytes Read
  19          SEGMENT_VARIABLE(M_State, U8, SEG_DATA);     // Current Machine State
  20          SEGMENT_VARIABLE(BytesWrote, U16, SEG_DATA); // Number of Bytes Written
  21          SEGMENT_VARIABLE(ReadIndex, U8*, SEG_DATA);
  22          SEGMENT_VARIABLE(BytesToWrite, U16, SEG_DATA);
  23          idata unsigned  char Buffer[56];
  24          //-----------------------------------------------------------------------------
  25          // UART1 Global Variables
  26          //-----------------------------------------------------------------------------
  27          xdata unsigned int errorTime;
  28          
  29          bit IsUSBRxReady;
  30          bit IsDrugReady;
  31          unsigned char RxTimeOutCount=0,CNumber ; // UART 接收超時時間設定
  32          idata unsigned char PNumber;
  33          bit IsCarbonEntry=0;
  34          bit IsCancelPack =0;    
  35          bit IsPrintDate =0;
  36          bit IsPrintNumber =1;
  37          
  38          bit IsCut=0;
  39          bit IsFR=0;
  40          bit IsAgain =0;
  41          bit IsShowCarbonEntry=0;
  42          bit CarbonBTW = 0;
  43          unsigned char *Pointer_Packer = &Packer.UART_Mark;
  44          
  45          bit     IsRxTimeOut =0; 
  46          bit CounterTag = 0,Dir = 0,CarbonTag = 0;
  47          //bit s = 0;
  48          unsigned char Counter,TempPWM = 0; 
  49          unsigned int DrugStartPosition   = 280 ,CarbonError = 0;
  50          unsigned char IMGSer = 0;
  51          //TSize PGMode;
  52          //-----------------------------------------------------------------------------
  53          // 主程式
  54          //-----------------------------------------------------------------------------
  55          
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 2   

  56          void ini_u14(){
  57   1              _Sel = 1;
  58   1              P2=0xEF;
  59   1              Delay(20);
  60   1      
  61   1              P4=0x90;
  62   1              _A1=1;_A0=1;
  63   1              _RD=1;
  64   1              _WR=0;
  65   1              Delay(10);
  66   1              _WR=1;
  67   1              Delay(20);
  68   1              _Sel = 0;
  69   1      }
  70          
  71          void ini_u15(){
  72   1              _Sel = 1;
  73   1              P2=0xFF;
  74   1              _RESET = 1;
  75   1              _RESET = 0;
  76   1              P4=0x92;
  77   1              _A1=1;_A0=1;
  78   1              _RD=1;
  79   1              _WR=0;
  80   1              Delay(10);
  81   1              _WR=1;
  82   1              Delay(20);
  83   1              _Sel = 0;
  84   1      }
  85          
  86          void Powder(unsigned char type,unsigned char pwm)
  87          {
  88   1              if (type == MotorStop)
  89   1              {
  90   2                      u14 = u14PC_PowderStop;
  91   2              }
  92   1              else if (type == MotorLeft)
  93   1              {
  94   2                      u14 = u14PC_PowderLeft;
  95   2              }
  96   1              else if (type ==MotorRight)
  97   1              {
  98   2                      u14 = u14PC_PowderRight;
  99   2          }
 100   1              Delay(50);
 101   1              PCA0CPH0=pwm;
 102   1      }
 103          void _u14pb(unsigned char MOD){
 104   1              _Sel = 1;
 105   1              P2=0xEF;
 106   1              P4=MOD;
 107   1              _RESET = 0;
 108   1              _A1=0;_A0=1;
 109   1              _RD=1;
 110   1              _WR=0;
 111   1              _WR=1;
 112   1              _Sel = 0;
 113   1      }
 114          void _u14pc(unsigned char MOD){
 115   1              _Sel = 1;
 116   1              P2=0xEF;
 117   1              P4=MOD;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 3   

 118   1              _RESET = 0;
 119   1              _A1=1;_A0=0;
 120   1              _RD=1;
 121   1              _WR=0;
 122   1              _WR=1;  
 123   1              _Sel = 0;
 124   1      }
 125          void _u15pc(unsigned char MOD){
 126   1              _Sel = 1;
 127   1              P2=0xFF;
 128   1              P4 = MOD;
 129   1              _RESET = 0;
 130   1              _RD=1;
 131   1              _A1=1;_A0=0;
 132   1              _WR=0;
 133   1              _WR=1;  
 134   1              _Sel = 0;               
 135   1      }
 136          
 137          void _u15Motor(unsigned char MOD){
 138   1              _Sel = 1;
 139   1              P2=0xFF;
 140   1              P4 = MOD;
 141   1              _RESET = 0;
 142   1              _RD=1;
 143   1              _A1=1;_A0=0;
 144   1              _WR=0;
 145   1              _WR=1;  
 146   1              _Sel = 0;               
 147   1      }
 148          void Cuter(void){
 149   1              Delay(6000);    
 150   1              _Sel = 1;
 151   1              P2=0xEF;
 152   1              P4=0x7F;
 153   1              _RESET = 0;
 154   1              _A1=0;_A0=1;
 155   1              _RD=1;
 156   1              _WR=0;
 157   1              _WR=1;
 158   1              _Sel = 0;
 159   1              Delay(15000);           
 160   1              _Sel = 1;
 161   1              P2=0xEF;
 162   1              P4=0xFF;
 163   1              _RESET = 0;
 164   1              _A1=0;_A0=1;
 165   1              _RD=1;
 166   1              _WR=0;
 167   1              _WR=1;
 168   1              _Sel = 0;
 169   1              Delay(8000);            
 170   1      }
 171          //-----------------------------------------------------------------------------
 172          
 173          void USBPrint(unsigned int Line)
 174          {
 175   1              unsigned char i,d;
 176   1      
 177   1              #define Bottom  0
 178   1              unsigned char tmpEIE1;
 179   1              unsigned char tmpEIE2;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 4   

 180   1              tmpEIE1 = EIE1;
 181   1              tmpEIE2 = EIE2;
 182   1      
 183   1              EA =0;
 184   1              EIE1 = 0;
 185   1              EIE2 = 0;
 186   1      
 187   1              _u15pc(u15pc |= 0x10);  //      u15 = u15PC_PaperCKH;
 188   1      
 189   1              if (Line < Packer.PgMode[USB.PgMode].Left || Line >= Packer.PgMode[USB.PgMode].Right)
 190   1              {
 191   2                      for (i=1;i<=55;i++)
 192   2                      {
 193   3                              while(!TXBMT);
 194   3                              SPIF=0;
 195   3                              SPI0DAT = 0x00;
 196   3                      }
 197   2              }
 198   1              else 
 199   1              {
 200   2                      for (i=1;i<=55;i++)
 201   2                      {
 202   3                              while(!TXBMT);
 203   3                              SPIF=0;
 204   3                              if (i<=Bottom || i>=Bottom +55 ) 
 205   3                                      SPI0DAT = 0x00;
 206   3                              else                                    
 207   3                                      SPI0DAT = mem[!IMGSer][Line-Packer.PgMode[USB.PgMode].Left][i-Bottom];
 208   3                      }
 209   2              }
 210   1      
 211   1              d=200; while(d--);
 212   1      
 213   1              TPHControl();
 214   1      
 215   1              EA=1;
 216   1              EIE1 = tmpEIE1 ;
 217   1              EIE2 = tmpEIE2 ;
 218   1              FiveStep();
 219   1      
 220   1      }
 221          void USBPack(bit IsDrug,bit IsPrint)
 222          {
 223   1              unsigned int Line,H;
 224   1              Delay(100);
 225   1      
 226   1              if (! IsCancelPack)
 227   1              {
 228   2                      // 溫度提高
 229   2      
 230   2                              Packer.Cpu1.HeaterPWM = TempPWM_Packing ;       
 231   2                              USB.Command = USBCommand_MemroyWrite;   
 232   2                              IsUSBRxReady = 0;
 233   2                              errorTime = Time_USB ;  
 234   2                              for(Line = 0;Line <Packer.PgMode[USB.PgMode].Length ; Line++)
 235   2                              {
 236   3                                      if(IsPrint)
 237   3                                      {
 238   4                                      USBPrint(Line);
 239   4                                      if(Line == Packer.PgMode[USB.PgMode].Left)
 240   4                                      {
 241   5                                              Carbon(1);
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 5   

 242   5                                              u15pc |= 0x08;
 243   5                                      }
 244   4                                      if(Line == Packer.PgMode[USB.PgMode].Right)
 245   4                                      {
 246   5                                              u15pc &= 0xF7;
 247   5                                              Carbon(0);      
 248   5                                      }
 249   4                                      }
 250   3                                      else
 251   3                                      {
 252   4                                              u15 = u15PC_PaperCKH;           
 253   4                                              H = Time_FiveStepDelay; while(H--);
 254   4                                              u15 = u15PC_PaperCKL;           
 255   4                                              H = Time_FiveStepDelay; while(H--);
 256   4                                              u15 = u15PC_PaperCKH;           
 257   4                                              H = Time_FiveStepDelay; while(H--);
 258   4                                              u15 = u15PC_PaperCKL;           
 259   4                                              H = Time_FiveStepDelay; while(H--);
 260   4                                              u15 = u15PC_PaperCKH;           
 261   4                                              H = Time_FiveStepDelay; while(H--);
 262   4                                              u15 = u15PC_PaperCKL;           
 263   4                                              H = Time_FiveStepDelay; while(H--);     
 264   4                                      }
 265   3                              }
 266   2              }       
 267   1              Delay(10);
 268   1              MainMotorPress();
 269   1              while(!IsUSBRxReady&&IsPrint) 
 270   1              {
 271   2              //      CheckErrorCode(ErrorCode_USBConnection);
 272   2                      i_Delay(52);
 273   2              }
 274   1              Packer.Cpu1.ImageNumber ++;
 275   1              ClosePrinter();
 276   1      if(IsDrug)
 277   1      {
 278   2      //      USB.Command = USBCommand_DrugsReady;    
 279   2      //      Packer.Cpu1.State = Cpu1State_Waiting;
 280   2              errorTime = Time_USB ;
 281   2              while(!IsDrugReady) 
 282   2              {
 283   3              //      CheckErrorCode(ErrorCode_USBConnection);
 284   3                      i_Delay(52);
 285   3              }
 286   2              Packer.Cpu1.State = Cpu1State_Packing;
 287   2              Cuter();
 288   2              USB.Command = USBCommand_DrugsReady;    
 289   2              Packer.Cpu1.State = Cpu1State_Waiting;
 290   2              IsDrugReady = 0;
 291   2              while(USB.Command == USBCommand_DrugsReady);
 292   2      
 293   2              
 294   2      }
 295   1      
 296   1              USB.Command = USBCommand_Idel;
 297   1      }
 298          //-----------------------------------------------------------------------------
 299          void TPHControl()
 300          {
 301   1              unsigned char d;
 302   1              _u14pb(0xEF);   //LATCH
 303   1              d=10;while(d--);
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 6   

 304   1              _u14pb(0xFF);   
 305   1      
 306   1              d = 60; while(d--);     
 307   1              // step 1       
 308   1      
 309   1              _u15pc(u15pc &= 0xEF);//        u15 = u15PC_PaperCKL:;
 310   1                      
 311   1              _u14pb(0xFC);//STROBE1,2
 312   1              
 313   1              Delay(10);
 314   1      
 315   1              _u14pb(0xFF);   
 316   1      
 317   1              d = 50; while(d--);     
 318   1              // step 2
 319   1              _u15pc(u15pc |= 0x10);  //      u15 = u15PC_PaperCKH;
 320   1      
 321   1              _u14pb(0xF3);//STROBE3,4        
 322   1      
 323   1              Delay(10);
 324   1        
 325   1              _u14pb(0xFF);
 326   1      }
 327          //-----------------------------------------------------------------------------
 328          void FiveStep()
 329          {
 330   1              unsigned int d;
 331   1              u15 = u15PC_PaperCKL;           
 332   1              d = Time_FiveStepDelay; while(d--);
 333   1              u15 = u15PC_PaperCKH;           
 334   1              d = Time_FiveStepDelay; while(d--);
 335   1              u15 = u15PC_PaperCKL;           
 336   1              d = Time_FiveStepDelay; while(d--);
 337   1      
 338   1      }
 339          
 340          void _u15PAR(){
 341   1              _Sel = 1;
 342   1              P2=0xFF;
 343   1              P4|=0x7F;
 344   1              _WR=1;_RD=0;
 345   1              _A1=0;_A0=0;
 346   1              u15_PA = P4;
 347   1              _Sel = 0;
 348   1      }
 349          void _u15PBR(){
 350   1              _Sel = 1;
 351   1              P2=0xFF;
 352   1              P4|=0xFC;
 353   1              _WR=1;_RD=0;
 354   1              _A1=0;_A0=1;
 355   1              u15_PB = P4;
 356   1              _Sel = 0;
 357   1      }
 358          void _u14PAR(){
 359   1              _Sel = 1;
 360   1              P2=0xEF;
 361   1              P4|=0x0F;
 362   1              _WR=1;_RD=0;
 363   1              _A1=0;_A0=0;
 364   1              u14_PA = P4;
 365   1              _Sel = 0;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 7   

 366   1      }
 367          
 368          //-----------------------------------------------------------------------------
 369          void Port_Ini(){
 370   1      
 371   1          P0MDOUT   = 0x00;
 372   1              P1MDOUT   = 0x10;
 373   1          P2MDOUT   = 0xFF;
 374   1          P3MDOUT   = 0xFF;
 375   1          P0SKIP    = 0x01;
 376   1              P1SKIP    = 0xC0;
 377   1              P1MDIN    = 0xFF;
 378   1          XBR0      = 0x06;
 379   1          XBR1      = 0x43;
 380   1        //  XBR2      = 0x01;
 381   1              P0MDIN   &= ~0x10;
 382   1      
 383   1      }
 384          
 385          
 386          void Interrupts_Init()
 387          {
 388   1          EIE2      = 0x02;
 389   1          IE        = 0x80;
 390   1      }
 391          
 392          void Timer2_ISR (void) interrupt INTERRUPT_TIMER2 
 393          {
 394   1              TF2H=0;
 395   1              if (RxTimeOutCount ++ >=3)
 396   1              {
 397   2                      TR2 =0;
 398   2                      TMR2H = 0x00;
 399   2                      TMR2L = 0x00;
 400   2                      RxTimeOutCount=0;
 401   2                      Pointer_Packer =&Packer.Cpu1.Command_UART;
 402   2                      IsRxCommand =1;
 403   2              }
 404   1      }
 405          void SYSCLK_Init (void)
 406          {
 407   1         OSCICN |= 0x03;                     // Configure internal oscillator for
 408   1                                             // its maximum frequency
 409   1         RSTSRC  = 0x04;                     // Enable missing clock detector
 410   1      }
 411          void Timer2_Init(){
 412   1              TMR2CN = 0x00;
 413   1              TMR2L  = 0x00;
 414   1              TMR2H  = 0x00;
 415   1          ET2 = 1;
 416   1      }
 417          void EMIF_Init()
 418          {
 419   1              EMI0TC = 0xFF;
 420   1              EMI0CF = 0x17;
 421   1              EMI0CN = 0x00;
 422   1      }
 423          //-----------------------------------------------------------------------------
 424          void MemoryClear()
 425          {
 426   1              unsigned int j,x;
 427   1      
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 8   

 428   1              for (j=0;j<520;j++)
 429   1              {
 430   2                      for(x = 0;x<55;x++)
 431   2                      {
 432   3                              mem[1][j][x] = 0x00;
 433   3                      
 434   3                      }
 435   2              }
 436   1      
 437   1      }
 438          void MainMotorRun()
 439          {
 440   1      
 441   1              if(U14_5){
 442   2                      while(U14_5)
 443   2                      {
 444   3                              PaperMotorForward();                    
 445   3                      }
 446   2                      IsFR =1;
 447   2              }
 448   1              else if(U14_6){
 449   2                      while(U14_6)
 450   2                      {
 451   3                              PaperMotorReverse();            
 452   3                      }
 453   2                      IsFR =1;
 454   2              }
 455   1              else if(U14_7){
 456   2                      PaperMotorLocate();                             
 457   2                      IsFR =1;
 458   2              }
 459   1      
 460   1      }
 461          /*
 462          void DrugLeaveRSW()
 463          {
 464                  bit SWState=0;
 465                  u14 = u14PC_DrugLeft;
 466                  Delay(10);
 467                  PCA0CPH2 = 0x40;
 468                  errorTime = Time_DrugLeaveRSW ;
 469                  while(DrugRSW==0) 
 470                  {
 471                          SWState =1;
 472                          i_Delay(Time_PSDelay);
 473                          CheckErrorCode(ErrorCode_Drug);
 474                  } 
 475          
 476                  if (SWState) Delay(400);
 477                  u14 = u14PC_DrugStop;
 478                  Delay(1600);
 479          }*/
 480          void main()
 481          {   
 482   1      
 483   1              unsigned int i=0x0000,time = 1100,d;
 484   1              //==============================
 485   1          PCA0MD &= ~0x40; 
 486   1          USB_Clock_Start();            // Init USB clock *before* calling USB_Init
 487   1          USB_Init(USB_VID,USB_PID,USB_MfrStr,USB_ProductStr,USB_SerialStr,USB_MaxPower,USB_PwAttributes,USB_bcd
             -Device);        
 488   1          USB_Int_Enable();             // Enable USB_API Interrupts
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 9   

 489   1      
 490   1              //==============================
 491   1      
 492   1              EA = 0;
 493   1      //      UART1_Init();
 494   1              IT01CF = 0x08;
 495   1              SPI_Init();
 496   1              Port_Ini();
 497   1          OSCILLATOR_Init ();                 // Initialize oscillator
 498   1              SMB0CF = 0x88;
 499   1              SMB0CN = 0x00;
 500   1              FLSCL = 0x10;
 501   1          PCA0_Init ();                       // Initialize PCA0
 502   1              ini_u15();
 503   1      
 504   1              ini_u14();
 505   1              EMIF_Init();
 506   1              Timer0_Init();
 507   1              Timer2_Init();
 508   1              ADC0_Init();
 509   1      //      SYSCLK_Init();
 510   1              
 511   1      //      u14pc=0x00;u15pc=0x40;
 512   1              u14pb=0xFF;
 513   1              _u14pb(u14pb);
 514   1      
 515   1              IsFR=1;
 516   1              Packer.Cpu1.Command_USB = Cpu1Command_Idel;     
 517   1              Packer.Cpu1.Command_UART = Cpu1Command_Idel;    
 518   1              Packer.Cpu1.NowNumber =0;
 519   1              Packer.Cpu1.PowderLocation =0;
 520   1              Packer.Cpu1.Thermometer =50 ;   
 521   1              Packer.Cpu1.ImageNumber =0;
 522   1              Packer.ErrorCode =0;
 523   1              Packer.Cpu1.State = Cpu1State_Heating;
 524   1              Packer.Cpu1.PowderStartPosition.W =18;
 525   1              Packer.Cpu1.DrugStartPosition.W   =300;
 526   1              Packer.Cpu1.InitTempTime.W =3000;               
 527   1              Packer.Cpu1.ShakeArray[0].W = 350;
 528   1              Packer.Cpu1.ShakeArray[1].W = 382;              
 529   1              Packer.Cpu1.ShakeArray[2].W = 430;              
 530   1              Packer.Cpu1.ShakeArray[3].W = 442;              
 531   1              Packer.Cpu1.ShakeArray[4].W = 490;              
 532   1              Packer.Cpu1.ShakeArray[5].W = 502;              
 533   1              Packer.Cpu1.VacuumType = VacuumType_Stop ;
 534   1              Packer.Cpu1.ForwardNumber.W =160;                       
 535   1              Packer.Cpu1.ReverseNumber.W =160;                       
 536   1              Packer.Cpu1.PowderCoverOpenNumber =2;   
 537   1              Packer.Cpu1.DrugCoverOpenNumber   =2;   
 538   1              Packer.Cpu1.HeaterPWM = TempPWM_MaxPower;
 539   1      //      Packer.Cpu1.CarbonPWM =0x10;
 540   1              Packer.Cpu1.Message = Message_Heating;
 541   1              Packer.ErrorCode = ErrorCode_NoError;
 542   1              Packer.UART_Mark = UART_Mark;
 543   1              /*
 544   1              Packer.PgMode[0].Left   = 60;
 545   1              Packer.PgMode[0].Right  = 452;
 546   1              Packer.PgMode[0].Length = 512;
 547   1              Packer.PgMode[0].SpacePg = 4;*/
 548   1              Packer.PgMode[0].Left   = 20;
 549   1              Packer.PgMode[0].Right  = 540;
 550   1              Packer.PgMode[0].Length = 576;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 10  

 551   1              Packer.PgMode[0].SpacePg = 3;
 552   1      
 553   1              Packer.PgMode[1].Left   = 60;
 554   1              Packer.PgMode[1].Right  = 580;
 555   1              Packer.PgMode[1].Length = 640;
 556   1              Packer.PgMode[1].SpacePg = 3;
 557   1              Packer.PgMode[2].Left   = 180;
 558   1              Packer.PgMode[2].Right  = 700;
 559   1              Packer.PgMode[2].Length = 853;
 560   1              Packer.PgMode[2].SpacePg = 2;
 561   1              USB.Command = USBCommand_Idel;
 562   1      
 563   1              EA = 1;
 564   1      
 565   1      
 566   1              DisableAllDriver();
 567   1              MemoryClear();
 568   1      
 569   1              Packer.Cpu1.HeaterPWM = TempPWM_Standby;
 570   1      
 571   1              #if !IsPowderOnly
              
                              DrugToRight();          
              
                              DrugCoverOpen();        
                      #endif
 577   1      
 578   1              while(1){
 579   2      
 580   2                      byte Command ;
 581   2                      Cpu1CommandIdel();
 582   2                      Packer.Cpu1.State = Cpu1State_Idel;
 583   2      /*
 584   2                      while(Cpu1Command() == Cpu1Command_Idel && !IsPacking)
 585   2                      {
 586   2                              AccessCpu0(Cpu0Command_ShowInfo);
 587   2      
 588   2                              #if IsMainMotorButton
 589   2                                      //MainMotorRun();
 590   2                              #endif
 591   2      
 592   2                              if (RHall != 0 )
 593   2                              {
 594   2                                      Delay(3000);                                    
 595   2                                      //PowderLocate();
 596   2                              }
 597   2                              Delay(30000);
 598   2                      }
 599   2      */
 600   2                      //SpacePacking(1);
 601   2                      Command = Cpu1Command() ;
 602   2                      Packer.Cpu1.State = Cpu1State_Busy;     
 603   2      //              AccessCpu0(Cpu0Command_ShowInfo);
 604   2      
 605   2                      if(Command == Cpu1Command_PackStart)
 606   2                      {
 607   3                              Packing();      
 608   3                              Delay(200);
 609   3                              Packer.Cpu1.Command_UART = Cpu1Command_Idel;
 610   3                      }
 611   2                      else if (Command == Cpu1Command_PaperMotorLocate)
 612   2                      {
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 11  

 613   3                              time = 1000;
 614   3                              u15 = u15PC_PaperCW ;
 615   3                              Delay(10);
 616   3                              u15 = u15PC_PaperEnable;
 617   3                              Delay(10);
 618   3                              for (i=0;i<640;i++)
 619   3                              {
 620   4                                      u15 = u15PC_PaperCKH;           
 621   4                                      d = time;       while(d--);
 622   4                                      u15 = u15PC_PaperCKL;           
 623   4                                      d = time;       while(d--);
 624   4                                      u15 = u15PC_PaperCKH;           
 625   4                                      d = time;       while(d--);
 626   4                                      u15 = u15PC_PaperCKL;           
 627   4                                      d = time;       while(d--);
 628   4                                      u15 = u15PC_PaperCKH;           
 629   4                                      d = time;       while(d--);
 630   4                                      u15 = u15PC_PaperCKL;           
 631   4                                      d = time;       while(d--);
 632   4                              }
 633   3                              u15 = u15PC_PaperDisable;               
 634   3                              //Cuter();
 635   3                              MainMotorPress();
 636   3                      }
 637   2                      else if(Command == Cpu1Command_MototPressFit)
 638   2                      {
 639   3                              u15 = u15PC_PaperPressON;
 640   3                              Delay(10);
 641   3                              errorTime = Time_PresurePS ;
 642   3                              do 
 643   3                              {
 644   4                                      i_Delay(Time_PSDelay);
 645   4                                      CheckErrorCode(ErrorCode_PresureDown);  
 646   4                              } while(PowderCounterPS==1);
 647   3                              
 648   3                              Delay(500);
 649   3                              do 
 650   3                              {
 651   4                                      i_Delay(Time_PSDelay);
 652   4                                      CheckErrorCode(ErrorCode_PresureDown);  
 653   4                              } while(PowderCounterPS==0);
 654   3                              u15 = u15PC_PaperPressOFF;
 655   3                              Delay(100);
 656   3                      }
 657   2                      else if(Command == Cpu1Command_USBPackStart)
 658   2                      {
 659   3                              USBPacking();
 660   3                              //_u14pb(0x7F);//STROBE1,2
 661   3                              Delay(100);
 662   3                              //_u14pb(0xFF);//STROBE1,2
 663   3                      }
 664   2                      Delay(1000);
 665   2      
 666   2              }
 667   1      }
 668          void MainMotorPress()
 669          {
 670   1              u15 = u15PC_PaperPressON;
 671   1              Delay(10);
 672   1              errorTime = Time_PresurePS ;
 673   1              do 
 674   1              {
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 12  

 675   2                      i_Delay(Time_PSDelay);
 676   2                      CheckErrorCode(ErrorCode_PresureDown);  
 677   2              } while(PowderCounterPS==1);
 678   1              
 679   1              Delay(500);
 680   1              do 
 681   1              {
 682   2                      i_Delay(Time_PSDelay);
 683   2                      CheckErrorCode(ErrorCode_PresureDown);  
 684   2              } while(PowderCounterPS==0);
 685   1              u15 = u15PC_PaperPressOFF;
 686   1              Delay(100);
 687   1      }
 688          //-----------------------------------------------------------------------------
 689          unsigned char Read_S=0x00, Mark = 0xFF;
 690          void USBPacking() 
 691          {
 692   1      
 693   1              Packer.Cpu1.State = Cpu1State_Packing;
 694   1              //AccessCpu0(Cpu0Command_ShowLeftDownGroupBox);
 695   1      
 696   1              //CheckPauseState(1);
 697   1      
 698   1              if (! IsCancelPack)
 699   1              {
 700   2              
 701   2      
 702   2                      PackForUSB();
 703   2                      IsPacking =0; 
 704   2      
 705   2              }
 706   1      
 707   1      
 708   1              Delay(2000);
 709   1              Packer.Cpu1.State = Cpu1State_Idel;
 710   1              Packer.Cpu1.NowNumber =0;
 711   1              //AccessCpu0(Cpu0Command_ShowPackFinish);
 712   1      
 713   1              Packer.Cpu1.Message = Message_PackFinish;
 714   1      
 715   1              Delay(4000);
 716   1              MemoryClear();
 717   1              //AccessCpu0(Cpu0Command_ShowSystemReady);
 718   1              Packer.Cpu1.Message = Message_SystemReady;              
 719   1      
 720   1              Packer.Cpu1.HeaterPWM = TempPWM_Standby ;               
 721   1              Cpu1CommandIdel();      
 722   1      }
 723          //-----------------------------------------------------------------------------
 724          void DrugCoverOpen()
 725          {
 726   1              unsigned char i;
 727   1              i = Packer.Cpu1.DrugCoverOpenNumber ;
 728   1              if (i>4) i=2;
 729   1      
 730   1              u14 = u14PC_DrugCoverStart ;
 731   1              Delay(50);
 732   1              while(i--)
 733   1              {
 734   2                      errorTime = Time_DrugCoverPS ;
 735   2                      do 
 736   2                      {
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 13  

 737   3                              i_Delay(Time_PSDelay);
 738   3                              CheckErrorCode(ErrorCode_DrugCover);
 739   3                      } while(DrugCoverPS==1) ;
 740   2      
 741   2                      errorTime = Time_DrugCoverPS ;
 742   2                      do 
 743   2                      {
 744   3                              i_Delay(Time_PSDelay);
 745   3                              CheckErrorCode(ErrorCode_DrugCover);
 746   3                      } while(DrugCoverPS==0) ;
 747   2              }
 748   1              u14 = u14PC_DrugCoverStop ;
 749   1              Delay(800);
 750   1      }
 751          //-----------------------------------------------------------------------------
 752          
 753          void PackForUSB()
 754          {
 755   1              unsigned char PackNum = USB.PackNumber + Packer.PgMode[USB.PgMode].SpacePg;
 756   1      
 757   1              Packer.Cpu1.NowNumber = 0;
 758   1              //-----------------------------------------------
 759   1              
 760   1              USB.Command = USBCommand_MemroyWrite;   
 761   1              IsUSBRxReady = 0;
 762   1              errorTime = Time_USB ;
 763   1              while(!IsUSBRxReady) 
 764   1              {
 765   2              //      CheckErrorCode(ErrorCode_USBConnection);
 766   2                      i_Delay(52);
 767   2              }
 768   1      
 769   1      
 770   1              //-----------------------------------------------
 771   1              u15 = u15PC_PaperCW ;
 772   1              Delay(10);
 773   1              u15 = u15PC_PaperEnable;
 774   1              Delay(10);
 775   1              Carbonini();
 776   1              IsPacking =1;
 777   1      
 778   1              Packer.Cpu1.ImageNumber =0;
 779   1              USB.Command = USBCommand_DrugsReady;    
 780   1              Packer.Cpu1.State = Cpu1State_Waiting;  
 781   1              IsDrugReady = 0;
 782   1              MainMotorPress();
 783   1          IsShake = USB.IsShake;
 784   1              for (PNumber=1; PNumber <= PackNum; PNumber++)
 785   1              {
 786   2                      if(PNumber == PackNum)
 787   2                      {
 788   3                              Packer.Cpu1.NowNumber = PNumber-2 ;
 789   3                              Packer.Cpu1.ImageNumber =0;
 790   3      
 791   3                              USBPack(0,0);                   
 792   3                              if (IsCancelPack)
 793   3                              {
 794   4                                      return ;
 795   4                              }
 796   3                      }
 797   2                      else if (PNumber > (PackNum-Packer.PgMode[USB.PgMode].SpacePg))         
 798   2                      {
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 14  

 799   3                              Packer.Cpu1.NowNumber = PNumber-2 ;
 800   3                              Packer.Cpu1.ImageNumber =0;
 801   3      
 802   3                              USBPack(1,0);                   
 803   3                              if (IsCancelPack)
 804   3                              {
 805   4                                      return ;
 806   4                              }
 807   3                      }
 808   2      
 809   2                      else if (PNumber <=Packer.PgMode[USB.PgMode].SpacePg)                                           
 810   2                      {
 811   3      
 812   3                              Packer.Cpu1.NowNumber = 0;
 813   3      
 814   3                              USBPack(0,1);                   
 815   3                                                              
 816   3                              if (IsCancelPack)
 817   3                              {
 818   4                                      return ;
 819   4                              }
 820   3                      }
 821   2      
 822   2                      else if (PNumber > Packer.PgMode[USB.PgMode].SpacePg && PNumber <= PackNum-Packer.PgMode[USB.PgMode].Spa
             -cePg)
 823   2                      {
 824   3      
 825   3                              Packer.Cpu1.NowNumber = PNumber-2 ;     
 826   3                              USBPack(1,1);                   
 827   3                              if (IsCancelPack)
 828   3                              {
 829   4                                      return ;
 830   4                              }
 831   3                      }
 832   2      
 833   2              }
 834   1              Cuter();
 835   1              USBPack(0,0);
 836   1              USBPack(0,0);
 837   1              USBPack(0,0);
 838   1              Packer.Cpu1.Message = Message_PackSpace;
 839   1      
 840   1              u15 = u15PC_PaperDisable;
 841   1              Delay(10);
 842   1      
 843   1      }
 844          void SpacePacking(byte SpaceNumber)
 845          {
 846   1              for (PNumber=1; PNumber <= SpaceNumber; PNumber++)      // 空包
 847   1              {
 848   2                      Packer.Cpu1.NowNumber = PNumber ;
 849   2                      SpacePack();
 850   2                      if (IsCancelPack)
 851   2                      {
 852   3                              return ;
 853   3                      }
 854   2                              Delay(500);
 855   2                              MainMotorPress();
 856   2              }       
 857   1      }
 858          
 859          //-----------------------------------------------------------------------------
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 15  

 860          void CheckPauseState(bit IsPrint)
 861          {
 862   1      //      unsigned char tag=0;
 863   1      
 864   1              Packer.Cpu1.State = Cpu1State_Packing;
 865   1      //      AccessCpu0(Cpu0Command_ShowPackInfo);
 866   1      
 867   1              IsCancelPack =0;
 868   1              if (PaperEntrySW )
 869   1              {
 870   2                      Packer.Cpu1.State = Cpu1State_PackPause ;
 871   2                      AccessCpu0(Cpu0Command_ShowPaperEntry);
 872   2                      Packer.Cpu1.Message = Message_PaperEntryAlerm ;
 873   2      //              tag = 1;
 874   2              }
 875   1      
 876   1              if (IsPackPause)
 877   1              {
 878   2                      Packer.Cpu1.State = Cpu1State_PackPause ;
 879   2                      AccessCpu0(Cpu0Command_ShowPackPause);
 880   2                      Packer.Cpu1.Message = Message_PackPause ;
 881   2              }
 882   1      
 883   1          if (IsCarbonEntry && IsPrint) 
 884   1              {
 885   2                      IsShowCarbonEntry =1;
 886   2                      Packer.Cpu1.State = Cpu1State_PackPause ;
 887   2                      AccessCpu0(Cpu0Command_ShowCarbonEntry);
 888   2                      Packer.Cpu1.Message = Message_CarbonEntryAlerm ;
 889   2      
 890   2              }
 891   1              
 892   1              else 
 893   1              {
 894   2                      if (!IsShowCarbonEntry)
 895   2                      {
 896   3                              AccessCpu0(Cpu0Command_ShowCarbonNoEntry);
 897   3      //                      AccessUSB(USBCommand_ShowCarbonNoEntry);
 898   3                      }
 899   2              }
 900   1      
 901   1              if (PaperEntrySW ==1 || IsPackPause || IsShowCarbonEntry) 
 902   1              {
 903   2                      Packer.Cpu1.State = Cpu1State_PackPause ;
 904   2                      AccessCpu0(Cpu0Command_ShowInfo) ;
 905   2                      u15 = u15PC_PaperDisable;
 906   2                      Delay(10);
 907   2                      u15 = u15PC_SharkerOFF ;
 908   2                      ClosePrinter();
 909   2                      if (IsPrint)
 910   2                      {
 911   3                              Carbon(0);
 912   3                              Delay(10);
 913   3                              //PresureDown();
 914   3                      }
 915   2                      
 916   2                      while(1)
 917   2                      {                       
 918   3                              Packer.Cpu1.State = Cpu1State_PackPause ;
 919   3                              AccessCpu0(Cpu0Command_ShowInfo) ;      
 920   3      
 921   3                              if (Cpu1Command() == Cpu1Command_PackContinue && PaperEntrySW ==0) {
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 16  

 922   4                                      Cpu1CommandIdel() ;     
 923   4                                      Packer.Cpu1.Message = Message_SystemReady ;
 924   4                                      PaperMotorLocate();     
 925   4                                      ShowPackType();
 926   4                                      CNumber += 2;
 927   4                                      PNumber -= 1;
 928   4                                      u15 = u15PC_PaperEnable;
 929   4                                      if (IsPrint)
 930   4                                      {
 931   5                                              //PresureUp();
 932   5                                              Carbon(1);
 933   5                                      }
 934   4                                      Carbonini();
 935   4                                      IsShowCarbonEntry = 0;
 936   4                                      IsCancelPack =0;
 937   4                                      Packer.Cpu1.State = Cpu1State_Packing ;
 938   4                                      AccessCpu0(Cpu0Command_ShowPackContinue);
 939   4                                      break ;
 940   4                              }       
 941   3                              // 停止包裝
 942   3                              else if (Cpu1Command() == Cpu1Command_PackStop) 
 943   3                              {
 944   4                                      Cpu1CommandIdel() ;
 945   4                                      Packer.Cpu1.State = Cpu1State_Idel ;
 946   4                                      AccessCpu0(Cpu0Command_ShowPackStop);
 947   4                                      Carbonini();
 948   4                                      IsCancelPack =1;
 949   4                                      Packer.Cpu1.Message = Message_SystemReady ;
 950   4                                      IsPacking =0;
 951   4                                      break ;
 952   4                              }
 953   3                              #if IsMainMotorButton
 954   3                                      MainMotorRun();
 955   3                              #endif
 956   3                              Delay(30000);
 957   3                      }
 958   2      
 959   2                      AccessCpu0(Cpu0Command_ShowPaperReady);
 960   2              }
 961   1      }
 962          //-----------------------------------------------------------------------------
 963          void Packing()
 964          {
 965   1      
 966   1              Packer.Cpu1.State = Cpu1State_Packing;
 967   1              AccessCpu0(Cpu0Command_ShowLeftDownGroupBox);
 968   1      
 969   1              AccessCpu0(Cpu0Command_TxPackInfo);
 970   1      
 971   1              CheckPauseState(0);
 972   1              if (! IsCancelPack)
 973   1              {
 974   2                      if (PaperMotorPS != 1)
 975   2                      {
 976   3                              PaperMotorLocate();             
 977   3                      }
 978   2      
 979   2                      Packer.Cpu1.HeaterPWM = TempPWM_Packing ;
 980   2                      
 981   2              
 982   2      //              if (IsAutoOpen)
 983   2                      {
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 17  

 984   3                              if (Packer.Cpu0.PackType == PackType_Powder ||  Packer.Cpu0.PackType == PackType_Mix) 
 985   3                              {
 986   4      
 987   4                                      PowderCoverOpen();              
 988   4                                      
 989   4                                      //Packer.Cpu1.VacuumType = VacuumType_LowSpeed;
 990   4                              }
 991   3                              if (Packer.Cpu0.PackType == PackType_Drug || Packer.Cpu0.PackType == PackType_Mix) 
 992   3                              {
 993   4                                      DrugCoverOpen();                
 994   4                              }
 995   3                      }
 996   2                      IsPacking =1;
 997   2                      if (IsPrintPack )       
 998   2                      {
 999   3                              PackWithPrint();                
1000   3                      }
1001   2                      else                            
1002   2                      {
1003   3                              PackWithoutPrint();
1004   3                      }
1005   2                      IsPacking =0;   
1006   2                      #if !IsPowderOnly
                                      DrugToRight();  
                              #endif                          
1009   2                      IsPacking =0;
1010   2                      if ( Packer.Cpu0.PackType == PackType_Powder || 
1011   2                           Packer.Cpu0.PackType == PackType_Mix ) 
1012   2                      {
1013   3                              if (IsCancelPack)
1014   3                              { 
1015   4                                      Packer.Cpu1.VacuumType = VacuumType_Stop ;
1016   4                                      PowderNumber();
1017   4                              }
1018   3                              else
1019   3                              {
1020   4                                      AutoClear(); 
1021   4                              }
1022   3                      }
1023   2      
1024   2              }
1025   1      
1026   1              Delay(1000);
1027   1              Packer.Cpu1.State = Cpu1State_Idel;
1028   1              Packer.Cpu1.NowNumber =0;
1029   1              AccessCpu0(Cpu0Command_ShowPackFinish);
1030   1      //      AccessUSB(USBCommand_Idel);
1031   1              Packer.Cpu1.Message = Message_PackFinish;       
1032   1              Delay(8000);
1033   1              MemoryClear();
1034   1              AccessCpu0(Cpu0Command_ShowSystemReady);
1035   1              Packer.Cpu1.Message = Message_SystemReady;                      
1036   1              Packer.Cpu1.HeaterPWM = TempPWM_Standby ;               
1037   1              Cpu1CommandIdel();
1038   1      }
1039          //-----------------------------------------------------------------------------
1040          void PackWithoutPrint()
1041          {
1042   1              unsigned char PNumber;
1043   1              u15 = u15PC_PaperResetH;
1044   1              Delay(10);
1045   1              u15 = u15PC_PaperCW ;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 18  

1046   1              Delay(10);
1047   1              u15 = u15PC_PaperEnable;
1048   1              Delay(10);
1049   1              IsPacking =1;
1050   1      
1051   1              // 包裝藥粉.錠劑.混合
1052   1              ShowPackType();
1053   1              for (PNumber=1 ; PNumber <= Packer.Cpu1.PowderLocation ; PNumber++)     
1054   1              {
1055   2                      Packer.Cpu1.NowNumber =PNumber;
1056   2                      OnePack(Packer.Cpu0.PackType , PrintFalse,IsCut);
1057   2                      if(PNumber==1)
1058   2                              IsCut=1;
1059   2                      else
1060   2                              IsCut=0;
1061   2                      if (IsCancelPack)
1062   2                      {
1063   3                              // 取消包裝
1064   3                              return ;
1065   3                      }
1066   2              }
1067   1      
1068   1              AccessCpu0(Cpu0Command_ShowPackSpace);
1069   1      
1070   1              #if IsCuterOk
1071   1                      if(IsAutoCut)
1072   1                      {
1073   2                              SpacePacking(1);
1074   2                              Delay(5000);
1075   2                              _One(PackType_Space ,PrintFalse);
1076   2                              Delay(5000);
1077   2                              // 主馬達定位
1078   2                              PaperMotorLocate();
1079   2                      }       
1080   1                      else
1081   1                              SpacePacking(Packer.Cpu0.SpaceNumber);
1082   1              #else 
                              SpacePacking(Packer.Cpu0.SpaceNumber);          
                      #endif  
1085   1      //      PaperMotorLocate();
1086   1      
1087   1              u15 = u15PC_PaperDisable;
1088   1              Delay(10);
1089   1      }
1090          //========================================================
1091          void _One(unsigned char Type,bit IsPrint)
1092          {
1093   1              unsigned int n;
1094   1      
1095   1              CheckPauseState(IsPrint);
1096   1              u15 = u15PC_PaperEnable;
1097   1              Delay(10);
1098   1              if (! IsCancelPack)
1099   1              {
1100   2                      for (n=0;n< CutterPosition ;n++)
1101   2                      {
1102   3                              OneStep(Time_PaperMotorDelay);  
1103   3                      }
1104   2      
1105   2              Delay(15000);
1106   2                              
1107   2              Cuter();
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 19  

1108   2                              
1109   2              u15 = u15PC_SharkerOFF ;
1110   2              ClosePrinter();
1111   2              }
1112   1      }
*** WARNING C280 IN LINE 1091 OF printer.c: 'Type': unreferenced local variable
1113          void OnePack(unsigned char Type,bit IsPrint,bit IsCuts)
1114          {
1115   1              unsigned int n;
1116   1      
1117   1              CheckPauseState(IsPrint);
1118   1              if (! IsCancelPack)
1119   1              {
1120   2              
1121   2                      PCA0CPH0 = 0x60;
1122   2                      for (n=0;n< 640 ;n++)
1123   2                      {
1124   3      //                      TR1 = 0;
1125   3                              if (IsPrint) 
1126   3                              {
1127   4                                      Print(n,PNumber-1);
1128   4                                      if(n==CutterPosition&&IsCuts==1){
1129   5                                      #if IsCuterOk
1130   5                                              if(IsAutoCut)
1131   5                                              {
1132   6                                                      
1133   6                                                              Carbon(0);
1134   6                                                              Delay(15000);
1135   6                                                              EA = 0;Cuter();EA = 1;
1136   6                                                              Delay(10000);
1137   6                                                              Carbon(1);                      
1138   6                                              
1139   6                                              }
1140   5                                      #endif
1141   5                                      }
1142   4                              }
1143   3      
1144   3                              else     
1145   3                              {
1146   4                                      OneStep(Time_PaperMotorDelay-40);
1147   4                                      if(n==CutterPosition&&IsCuts==1){
1148   5                                      #if IsCuterOk
1149   5                                              if(IsAutoCut)
1150   5                                              {                                               
1151   6                                                      
1152   6                                                              Delay(15000);
1153   6                                                              EA = 0;Cuter();EA = 1;
1154   6                                                              Delay(10000);           
1155   6                                                                                                      
1156   6                                              }
1157   5                                      #endif  
1158   5                                      }
1159   4                              }
1160   3                              if (Type == PackType_Drug )             
1161   3                              {
1162   4                                      // 錠劑
1163   4                                      if (n == DrugStartPosition) 
1164   4                                              IsDrugMove =1;
1165   4                              }
1166   3                              
1167   3                              else if (Type == PackType_Mix)  
1168   3                              {
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 20  

1169   4                                      // 混合 
1170   4                                      if (n == DrugStartPosition)   
1171   4                                              IsDrugMove   =1;
1172   4                                      Shake(n) ;
1173   4                              }
1174   3                      }
1175   2      
1176   2              u15pc &= 0xF7;
1177   2      
1178   2              ClosePrinter();
1179   2              }
1180   1      }
1181          //-----------------------------------------------------------------------------
1182          void Shake(unsigned int n)
1183          {
1184   1              if (IsShake ==0) return;
1185   1              if ( n == Packer.Cpu1.ShakeArray[0].W || 
1186   1                       n == Packer.Cpu1.ShakeArray[2].W || 
1187   1                       n == Packer.Cpu1.ShakeArray[4].W )
1188   1              {
1189   2                      //u15 = u15PC_SharkerON ;
1190   2                      u15pc |= 0x08;
1191   2              }
1192   1              else if ( n == Packer.Cpu1.ShakeArray[1].W || 
1193   1                                n == Packer.Cpu1.ShakeArray[3].W || 
1194   1                                n == Packer.Cpu1.ShakeArray[5].W )
1195   1              {
1196   2                      //u15 = u15PC_SharkerOFF ;
1197   2                      u15pc &= 0xF7;
1198   2              }
1199   1              //Delay(10);
1200   1      }
1201          //-----------------------------------------------------------------------------
1202          void Carbonini()
1203          {
1204   1              CarbonTag = CarbonHall;
1205   1              CarbonError = 0;
1206   1              IsCarbonEntry = 0;
1207   1      
1208   1      }
1209          //-----------------------------------------------------------------------------
1210          void PackWithPrint()
1211          {
1212   1              unsigned char PackTotal = Packer.Cpu1.PowderLocation +2;
1213   1      
1214   1              HeadWithPrint();
1215   1      
1216   1              //PresureUp();
1217   1      
1218   1              Carbon(1);
1219   1              u15 = u15PC_PaperCW ;
1220   1              Delay(10);
1221   1              u15 = u15PC_PaperEnable;
1222   1              Delay(10);
1223   1              Carbonini();
1224   1              IsPacking =1;
1225   1      
1226   1              ShowPackType();
1227   1              for (PNumber=1;PNumber<= PackTotal;PNumber++)
1228   1              {
1229   2                      if(PNumber == 4)
1230   2                              IsCut = 1;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 21  

1231   2                      else
1232   2                              IsCut = 0;
1233   2                      if (PNumber == PackTotal-1)     
1234   2                      {
1235   3                              Carbon(0);
1236   3                              Delay(10);
1237   3                              
1238   3                      //      PresureDown();  
1239   3      
1240   3                              Packer.Cpu1.NowNumber =PNumber-2 ;              
1241   3      
1242   3                              OnePack(Packer.Cpu0.PackType , PrintFalse,IsCut);
1243   3                              if (IsCancelPack)
1244   3                              {
1245   4                                      return ;
1246   4                              }
1247   3                      }
1248   2                      else if (PNumber >= PackTotal)          
1249   2                      {
1250   3                              Packer.Cpu1.NowNumber =PNumber-2 ;              
1251   3                              OnePack(Packer.Cpu0.PackType , PrintFalse,IsCut);
1252   3                              if (IsCancelPack)
1253   3                              {
1254   4                                      return ;
1255   4                              }
1256   3                      }
1257   2                      else if (PNumber <=2 )                                  
1258   2                      {
1259   3                              Packer.Cpu1.NowNumber =0;
1260   3      
1261   3                              OnePack(PackType_Space , PrintTrue,IsCut);
1262   3                              if (IsCancelPack)
1263   3                              {
1264   4                                      return;
1265   4                              }
1266   3                      }
1267   2                      else if (PNumber > 2 && PNumber < PackTotal-1)
1268   2                      {
1269   3                              Packer.Cpu1.NowNumber =PNumber-2 ;              
1270   3                              
1271   3                              OnePack(Packer.Cpu0.PackType , PrintTrue,IsCut);
1272   3                              if (IsCancelPack)
1273   3                              {
1274   4                                      return;
1275   4                              }
1276   3                      }
1277   2      
1278   2      
1279   2              }
1280   1              #if IsCuterOk
1281   1                      if(IsAutoCut)
1282   1                      {
1283   2                              SpacePacking(1);
1284   2                              Delay(5000);
1285   2                              _One(PackType_Space ,PrintFalse);
1286   2                              Delay(5000);
1287   2                              // 主馬達定位
1288   2                              PaperMotorLocate();
1289   2                      }       
1290   1                      else
1291   1                              SpacePacking(Packer.Cpu0.SpaceNumber);
1292   1              #else 
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 22  

                              SpacePacking(Packer.Cpu0.SpaceNumber);          
                      #endif  
1295   1      //      PaperMotorLocate();     // 主馬達定位
1296   1      
1297   1              u15 = u15PC_PaperDisable;
1298   1              Delay(10);
1299   1      }
1300          //-----------------------------------------------------------------------------
1301          void Print(unsigned int Line,signed int Number)
1302          {
1303   1              unsigned char i;
1304   1              unsigned char tmpEIE1;
1305   1              unsigned char tmpEIE2;
1306   1      
1307   1              unsigned int Shift = 0 ;
1308   1              
1309   1              u15 = u15PC_PaperCKH;
1310   1              tmpEIE1 = EIE1;
1311   1              tmpEIE2 = EIE2;
1312   1      //      EA =0;
1313   1      //      EIE1 = 0;
1314   1      //      EIE2 = 0;
1315   1      
1316   1      
1317   1              if (Line < Packer.PgMode[0].Left || Line >= Packer.PgMode[0].Right)
1318   1              {
1319   2                      for (i=1;i<=80;i++)
1320   2                      {
1321   3                              while(!TXBMT);
1322   3                              SPIF=0;
1323   3                              SPI0DAT = 0x00;
1324   3                      }
1325   2              }
1326   1              else 
1327   1              {
1328   2                      unsigned char n,k;
1329   2                      for (i=0 ; i < 21 ; i++)
1330   2                      {
1331   3                              while(!TXBMT);
1332   3                              SPIF=0;
1333   3                              SPI0DAT = 0x00;
1334   3                      }
1335   2      
1336   2                      if (IsPrintDate)
1337   2                      {
1338   3                              for (i=0 ; i < 4 ; i++)
1339   3                              {
1340   4                                      while(!TXBMT);
1341   4                                      SPIF=0;
1342   4                                      if (Line >=Shift && Line < Shift+32 )
1343   4                                      {
1344   5                                              unsigned char n = 2;
1345   5                                              SPI0DAT = cA11[n][Line - Shift][i] ;
1346   5                                      }
1347   4                                      else if (Line >=Shift +32 && Line < Shift+64 )
1348   4                                      {
1349   5                                              unsigned char n = 0;
1350   5                                              SPI0DAT = cA11[n][Line - Shift -32][i] ;
1351   5                                      }
1352   4                                      else if (Line >=Shift +64 && Line < Shift+96 )
1353   4                                      {
1354   5                                              unsigned char n = 1;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 23  

1355   5                                              SPI0DAT = cA11[n][Line - Shift -64][i] ;
1356   5                                      }
1357   4                                      else if (Line >=Shift +96 && Line < Shift+128 )
1358   4                                      {
1359   5                                              unsigned char n = 1;
1360   5                                              SPI0DAT = cA11[n][Line - Shift -96][i] ;
1361   5                                      }
1362   4                                      else if (Line >=Shift +128 && Line < Shift+160 )
1363   4                                      {
1364   5                                              SPI0DAT = cA11[10][Line - Shift -128][i] ;
1365   5                                      }
1366   4                                      
1367   4                                      else if (Line >=Shift +160 && Line < Shift+192 )
1368   4                                      {
1369   5                                              unsigned char n = 0;
1370   5                                              SPI0DAT = cA11[n][Line - Shift -160][i] ;
1371   5                                      }
1372   4                                      else if (Line >=Shift +192 && Line < Shift+224 )
1373   4                                      {
1374   5                                              unsigned char n = 3;
1375   5                                              SPI0DAT = cA11[n][Line - Shift -192][i] ;
1376   5                                      }
1377   4                                      else if (Line >=Shift +224 && Line < Shift+256)
1378   4                                      {
1379   5                                              SPI0DAT = cA11[10][Line - Shift -224][i] ;
1380   5                                      }
1381   4      
1382   4                                      else if (Line >=Shift +256 && Line < Shift+288 )
1383   4                                      {
1384   5                                              unsigned char n = 0;
1385   5                                              SPI0DAT = cA11[n][Line - Shift -256][i] ;
1386   5                                      }
1387   4                                      else if (Line >=Shift +288 && Line < Shift+320 )
1388   4                                      {
1389   5                                              unsigned char n = 9;
1390   5                                              SPI0DAT = cA11[n][Line - Shift -288][i] ;
1391   5                                      }
1392   4                                      else SPI0DAT = 0x00;
1393   4                              }
1394   3                      }
1395   2      
1396   2                      if (IsPrintNumber)
1397   2                      {
1398   3                              for (i=0 ; i < 4 ; i++) 
1399   3                              {
1400   4                                      while(!TXBMT);
1401   4                                      SPIF=0;
1402   4                                      if (Line >=Shift && Line < Shift+32 )
1403   4                                      {
1404   5                                              unsigned char n = (Number +1) /10;
1405   5                                              SPI0DAT = cA11[n][Line - Shift][i] ;
1406   5                                      }
1407   4                                      else if (Line >=Shift +32 && Line < Shift+64 )
1408   4                                      {
1409   5                                              unsigned char n = (Number +1) %10;
1410   5                                              SPI0DAT = cA11[n][Line - Shift -32][i] ;
1411   5                                      }
1412   4                                      else if (Line >=Shift +64 && Line < Shift+96 )
1413   4                                      {
1414   5                                              SPI0DAT = cA11[10][Line - Shift -64][i] ;
1415   5                                      }
1416   4                                      else if (Line >=Shift +96 && Line < Shift+128 )
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 24  

1417   4                                      {
1418   5                                              unsigned char n = Packer.Cpu0.TotalNumber /10;
1419   5                                              SPI0DAT = cA11[n][Line - Shift -96][i] ;
1420   5                                      }
1421   4                                      else if (Line >=Shift +128 && Line < Shift+160 )
1422   4                                      {
1423   5                                              unsigned char n = Packer.Cpu0.TotalNumber %10;
1424   5                                              SPI0DAT = cA11[n][Line - Shift -128][i] ;
1425   5                                      }
1426   4                                      else SPI0DAT = 0x00;
1427   4                              }
1428   3                      }
1429   2      
1430   2                      for (i=0 ; i < 9 ; i++) 
1431   2                      {
1432   3                              while(!TXBMT);
1433   3                              SPIF=0;
1434   3                              SPI0DAT = 0;
1435   3                      }
1436   2      
1437   2                      k =0;
1438   2                      for (i=0; i<=3; i++)            // 4
1439   2                      {
1440   3                              if ( Packer.Cpu0.PrintItem[i] != 0 ) k++;
1441   3                      }
1442   2      
1443   2                      n =     (Number % k) *8  ;
1444   2      
1445   2                      for (i=0 ; i < 8 ; i++) 
1446   2                      {
1447   3                              while(!TXBMT);
1448   3                              SPIF=0;
1449   3                              SPI0DAT = mem[Line][n+i];
1450   3                      }
1451   2      
1452   2                      for (i=0 ; i < 4 ; i++) 
1453   2                      {
1454   3                              while(!TXBMT);
1455   3                              SPIF=0;
1456   3                              SPI0DAT = 0x00;
1457   3                      }
1458   2      
1459   2                      for (i=0 ; i < 4 ; i++) 
1460   2                      {
1461   3                              while(!TXBMT);
1462   3                              SPIF=0;
1463   3                              
1464   3                              if (IsPatientID)        
1465   3                              {
1466   4                                      SPI0DAT = mem[Line][i+36];
1467   4                              }
1468   3                              else                    SPI0DAT = 0x00;
1469   3                      }
1470   2      
1471   2      
1472   2                      for (i=0 ; i < 4 ; i++) 
1473   2                      {
1474   3                              while(!TXBMT);
1475   3                              SPIF=0;
1476   3                              if (IsDateTime) 
1477   3                              {
1478   4                                      SPI0DAT = mem[Line][i+32];
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 25  

1479   4                              }
1480   3                              else                    SPI0DAT = 0x00;
1481   3                      }
1482   2      
1483   2                      for(i=0;i<7;i++){
1484   3                               while(!TXBMT);
1485   3                              SPIF=0;         
1486   3                              SPI0DAT = 0x00;
1487   3                      }
1488   2      
1489   2                      for (i=0 ; i < 7; i++)
1490   2                      {
1491   3                              while(!TXBMT);
1492   3                              SPIF=0;
1493   3                              if (IsName && Line>138&&Line<330) SPI0DAT = CC[Line-138][i];
1494   3                              else            
1495   3                                      SPI0DAT = 0x00;
1496   3                      }
1497   2      
1498   2                      for (i=0 ; i < 9 ; i++) 
1499   2                              {
1500   3                              while(!TXBMT);
1501   3                              SPIF=0;
1502   3                              SPI0DAT = 0x00;
1503   3                      }
1504   2              }
1505   1      
1506   1              TPHControl();
1507   1      
1508   1      
1509   1      //      EA=1;
1510   1      //      EIE1 = tmpEIE1 ;
1511   1      //      EIE2 = tmpEIE2 ;
1512   1              FiveStep();
1513   1      }
1514          
1515          void SpacePack()
1516          {
1517   1              PaperMotorLocate();     
1518   1      }
1519          /*
1520          void EightStep()
1521          {
1522                  unsigned int d;
1523                  u15 = u15PC_PaperCKH;           
1524                  d = 1200;       while(d--);
1525                  u15 = u15PC_PaperCKL;           
1526                  d = 1200;       while(d--);
1527                  u15 = u15PC_PaperCKH;           
1528                  d = 1200;       while(d--);
1529                  u15 = u15PC_PaperCKL;           
1530                  d = 1200;       while(d--);
1531                  u15 = u15PC_PaperCKH;           
1532                  d = 1200;       while(d--);
1533                  u15 = u15PC_PaperCKL;           
1534                  d = 1200;       while(d--);
1535                  u15 = u15PC_PaperCKH;           
1536                  d = 1200;       while(d--);
1537                  u15 = u15PC_PaperCKL;           
1538                  d = 1200;       while(d--);
1539          }*/
1540          //-----------------------------------------------------------------------------
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 26  

1541          void ClosePrinter()
1542          {
1543   1              u14pb = 0xFF;
1544   1      }
1545          //===============================================
1546          
1547          void  State_Machine(void)
1548          {
1549   1         switch   (M_State)
1550   1         {
1551   2            case  ST_RX_SETUP:
1552   2               Receive_Setup();           // Receive and decode host Setup Message
1553   2               break;
1554   2            case  ST_RX_FILE:
1555   2               Receive_File();            // Receive File data from host
1556   2               break;
1557   2            case  ST_TX_ACK:
1558   2               M_State =   ST_RX_FILE;    // Ack Transmit complete, continue RX data
1559   2               break;
1560   2            case  ST_TX_FILE:             // Send file data to host
1561   2               WriteStageLength = ((BytesToWrite - BytesWrote) > MAX_BLOCK_SIZE_WRITE)? MAX_BLOCK_SIZE_WRITE:(By
             -tesToWrite - BytesWrote);
1562   2               BytesWrote  += Block_Write((unsigned char*)(ReadIndex), WriteStageLength);
1563   2               ReadIndex += WriteStageLength;
1564   2               break;
1565   2            default:
1566   2               break;
1567   2         }
1568   1      }
1569          
1570          
1571             // ISR for USB_API, run when API interrupts are enabled, and an interrupt is received
1572          void USB_API_TEST_ISR(void)interrupt    INTERRUPT_USBXpress
1573          {
1574   1         unsigned char  INTVAL   =  Get_Interrupt_Source();  // Determine type of API interrupts
1575   1         if (INTVAL  &  USB_RESET)                // Bus Reset Event, go to Wait State
1576   1         {
1577   2            M_State  =  ST_WAIT_DEV;
1578   2         }
1579   1      
1580   1         if (INTVAL  &  DEVICE_OPEN)            // Device opened on host, go to Idle
1581   1         {
1582   2            M_State  =  ST_IDLE_DEV;
1583   2         }
1584   1      
1585   1         if (INTVAL  &  TX_COMPLETE)
1586   1         {
1587   2            if (M_State == ST_RX_FILE)          // Ack Transmit complete, go to RX state
1588   2            {
1589   3               M_State  =  (ST_TX_ACK);
1590   3            }
1591   2            if (M_State == ST_TX_FILE)          // File block transmit complete, go to TX state
1592   2            {
1593   3               M_State  =  (BytesWrote == BytesToWrite) ? ST_IDLE_DEV :ST_TX_FILE;  // Go to Idle when done
1594   3            }
1595   2         }
1596   1         if (INTVAL  &  RX_COMPLETE)            // RX Complete, go to RX Setup or RX file state
1597   1         {
1598   2            M_State  =  (M_State == ST_IDLE_DEV) ? ST_RX_SETUP : ST_RX_FILE;
1599   2         }
1600   1         if (INTVAL  &  DEVICE_CLOSE)           // Device closed, wait for re-open
1601   1         {
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 27  

1602   2            M_State  =  ST_WAIT_DEV;
1603   2         }
1604   1         if (INTVAL  &  FIFO_PURGE)             // Fifo purged, go to Idle State
1605   1         {
1606   2            M_State  =  ST_IDLE_DEV;
1607   2         }
1608   1      
1609   1         State_Machine();                       // Call state machine routine
1610   1      }
1611          unsigned int IMGTAG = 0x0000;
1612          void  Receive_Setup (void)
1613          {
1614   1         char i = 0;
1615   1         BytesRead   =  Block_Read(&Buffer,  56);      // Read Setup Message
1616   1      
1617   1      
1618   1         if (Buffer[0]  == READ_MSG)         // Check See if Read File Setup
1619   1         {
1620   2                Packer.Cpu1.Command_USB   = Buffer[1];
1621   2                USB.PackType          = Buffer[2]; 
1622   2                USB.SpaceNumber       = Buffer[3];
1623   2                USB.PackNumber        = Buffer[4];
1624   2                USB.StartNumber       = Buffer[5];
1625   2                USB.TotalNumber       = Buffer[6];
1626   2                USB.PgMode            = Buffer[7];
1627   2                USB.IsShake           = Buffer[8];
1628   2                USB.Year                      = Buffer[9];
1629   2                USB.Month                     = Buffer[10];
1630   2                USB.Day                       = Buffer[11];
1631   2                USB.IsAutoCut = Buffer[12];
1632   2                USB.IsPrintNumber     = Buffer[13];
1633   2                IsDrugReady           = Buffer[14];
1634   2            Buffer[0]   =  Mark;            // Send host size of transfer message
1635   2                Buffer[1]       =  USB.Command;
1636   2            Buffer[2]   =  Packer.Cpu1.State;//Read_S; //LengthFile[1];
1637   2            Buffer[3]   =  Packer.Cpu1.NowNumber;//Signs;  //LengthFile[0];
1638   2                Buffer[4]       =  Packer.Cpu1.PowderLocation;//Packer.Cpu1.PowderLocation;
1639   2                Buffer[5]       =  Packer.Cpu1.Thermometer;
1640   2                Buffer[6]       =  Packer.Cpu1.ImageNumber;
1641   2                Buffer[7]   =  Packer.Cpu1.Message;
1642   2                Buffer[8]       =  Packer.ErrorCode;
1643   2                Buffer[9]       =  Read_S;
1644   2                Buffer[10]  =  0xFF;    
1645   2            BytesWrote  =  Block_Write((unsigned char*)&Buffer,   15);
1646   2                M_State =  ST_IDLE_DEV; 
1647   2                Read_S+=1;
1648   2                Mark = 0xFF;
1649   2      
1650   2         }
1651   1         else if(Buffer[0] == WRITE_DAT)
1652   1         {
1653   2                      for(i=1;i<56;i++)
1654   2                      {
1655   3                              mem[IMGSer][IMGTAG][i-1] = Buffer[i];
1656   3                      }
1657   2                      IMGTAG ++;
1658   2                      if(IMGTAG >= 520)
1659   2                      {
1660   3                              USB.Command = USBCommand_Idel;
1661   3                              IsUSBRxReady = 1;
1662   3                              IMGTAG = 0;
1663   3                              if(IMGSer == 0)
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 28  

1664   3                                      IMGSer = 1;
1665   3                              else
1666   3                                      IMGSer = 0;
1667   3                      }
1668   2                      else
1669   2                              USB.Command = USBCommand_MemroyWrite;
1670   2                      Buffer[1] = USB.Command;
1671   2                      BytesWrote  =  Block_Write((unsigned char*)&Buffer,   15);
1672   2                      M_State =  ST_IDLE_DEV;                 
1673   2         }
1674   1         else if(Buffer[0] == CommandACK)
1675   1         {
1676   2                      USB.Command = USBCommand_Idel;
1677   2                      Buffer[1] = USB.Command;
1678   2                      BytesWrote  =  Block_Write((unsigned char*)&Buffer,   15);
1679   2                      M_State =  ST_IDLE_DEV;  
1680   2         }
1681   1      }
1682          
1683          //===============================================
1684          //-----------------------------------------------------------------------------
1685          void PowderToLeft()
1686          {
1687   1              Packer.Cpu1.State = Cpu1State_PowderLocating;
1688   1              Powder(MotorLeft,PowderPWM);    
1689   1      
1690   1              errorTime = Time_PowderLSW ;
1691   1      
1692   1              while (PowderLSW)
1693   1              {
1694   2      //              Delay(1000);
1695   2      //              Delay(1000);
1696   2                      i_Delay(Time_PSDelay);
1697   2                      i_Delay(Time_PSDelay);
1698   2                      CheckErrorCode(ErrorCode_Powder);
1699   2              }
1700   1              Powder(MotorStop,0xFF);
1701   1              Delay(1000);
1702   1              Counter = Ini_Location;
1703   1              CounterTag = PowderCounterPS;
1704   1      }
1705          //-----------------------------------------------------------------------------
1706          void PowderToRight()
1707          {
1708   1              Packer.Cpu1.State = Cpu1State_PowderLocating;
1709   1              Powder(MotorRight,PowderPWM);
1710   1              
1711   1              errorTime = Time_PowderRSW ;
1712   1      
1713   1              while (PowderRSW)
1714   1              {
1715   2      //              Delay(1000);
1716   2      //              Delay(1000);
1717   2                      i_Delay(Time_PSDelay);
1718   2                      i_Delay(Time_PSDelay);
1719   2                      CheckErrorCode(ErrorCode_Powder);
1720   2              }
1721   1              Powder(MotorStop,0xFF);
1722   1              Delay(1000);
1723   1      }
1724          void DrugToRight()
1725          {
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 29  

1726   1              PCA0CPH2 = 0x40;
1727   1              u14 = u14PC_DrugRight;
1728   1              Delay(20);
1729   1      
1730   1              errorTime = Time_DrugRSW ;
1731   1      
1732   1              while(DrugRSW==1) 
1733   1              {
1734   2                      i_Delay(Time_PSDelay);
1735   2                      CheckErrorCode(ErrorCode_Drug);
1736   2              } 
1737   1      
1738   1              u14 = u14PC_DrugStop;
1739   1              Delay(800);
1740   1      }
1741          //-----------------------------------------------------------------------------
1742          void CloseLeave()
1743          {
1744   1              Powder(MotorLeft,PowderPWM);
1745   1              while(PowderCounterPS ==1 ) 
1746   1              {
1747   2                      if (PowderLSW ==0) 
1748   2                      {
1749   3                      Powder(MotorStop,0xFF);
1750   3                      Delay(1000);
1751   3                      return;
1752   3                      }
1753   2      
1754   2              }
1755   1              while(PowderCounterPS ==0 ) 
1756   1              {
1757   2                      if (PowderLSW ==0) 
1758   2                      {
1759   3                      Powder(MotorStop,0xFF);
1760   3                      Delay(1000);
1761   3                      return;
1762   3                      }
1763   2      
1764   2              }
1765   1      
1766   1              Powder(MotorStop,0xFF);
1767   1              Powder(MotorLeft,PowderPWM);
1768   1              while(PowderCounterPS ==1) 
1769   1              {
1770   2                      if (PowderLSW ==0) 
1771   2                      {
1772   3                      Powder(MotorStop,0xFF);
1773   3                      Delay(1000);
1774   3                      return;
1775   3                      }
1776   2      
1777   2              }
1778   1              while(PowderCounterPS ==0) 
1779   1              {
1780   2                      if (PowderLSW ==0) 
1781   2                      {
1782   3                      Powder(MotorStop,0xFF);
1783   3                      Delay(1000);
1784   3                      return;
1785   3                      }
1786   2              }
1787   1      
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 30  

1788   1              Powder(MotorStop,0xFF);
1789   1              Delay(1000);
1790   1      
1791   1              Powder(MotorRight,PowderPWM);
1792   1              while(PowderCounterPS ==1) ;
1793   1              while(PowderCounterPS ==0) ;
1794   1              Powder(MotorStop,0xFF);
1795   1              Powder(MotorRight,PowderPWM);
1796   1              while(PowderCounterPS ==1) ;
1797   1              while(PowderCounterPS ==0) ;
1798   1              Powder(MotorStop,0xFF);
1799   1      
1800   1              IsFR =0;
1801   1              Delay(1000);
1802   1      }
1803          //-----------------------------------------------------------------------------
1804          void PowderNumber()
1805          {
1806   1      
1807   1              unsigned char s=0;
1808   1              Packer.Cpu1.PowderLocation =0;          
1809   1              Packer.Cpu1.State = Cpu1State_PowderLocating;
1810   1              AccessCpu0(Cpu0Command_ShowPowderLocating);     
1811   1              Packer.Cpu1.Message = Message_PowderLocating;           
1812   1              //AccessUSB(USBCommand_Busy);   
1813   1      
1814   1              if (PaperMotorPS != 1)
1815   1              {
1816   2                      PaperMotorLocate();             
1817   2              }
1818   1      
1819   1      
1820   1              PowderToLeft();                                         
1821   1      
1822   1      
1823   1              PowderCounterPS_LastState = PowderCounterPS ;
1824   1              PowderLocationCounter = 0;
1825   1              PowderLocate();                                         
1826   1      }
1827          
1828          //-----------------------------------------------------------------------------
1829          void Carbon(bit bSW){
1830   1              CarbonBTW = bSW;
1831   1              PCA0CPH1  = 0xA0;
1832   1              if (bSW)
1833   1              {
1834   2                      u14 = u14PC_CarbonStart ;
1835   2      
1836   2              }
1837   1              else
1838   1              {
1839   2                      u14 = u14PC_CarbonStop ;
1840   2              }
1841   1      }
1842          //-----------------------------------------------------------------------------
1843          
1844          void PaperMotorForward()
1845          {
1846   1              unsigned int i;
1847   1              u15 = u15PC_PaperCW ;
1848   1              Delay(10);
1849   1              u15 = u15PC_PaperEnable;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 31  

1850   1              Delay(10);
1851   1              for (i=0 ; i < 80 ; i++)
1852   1              {
1853   2                      OneStep(800);   
1854   2              }
1855   1      
1856   1              u15 = u15PC_PaperDisable;
1857   1      }
1858          //-----------------------------------------------------------------------------
1859          void PaperMotorReverse()
1860          {
1861   1              unsigned int i;
1862   1              u15 = u15PC_PaperCCW ;
1863   1              Delay(10);
1864   1              u15 = u15PC_PaperEnable;
1865   1              Delay(10);
1866   1              for (i=0 ; i < 80 ; i++)
1867   1              {
1868   2                      OneStep(800);   
1869   2              }
1870   1              u15 = u15PC_PaperDisable;
1871   1      }
1872          //-----------------------------------------------------------------------------
1873          void PaperMotorLocate()
1874          {
1875   1              unsigned char i;
1876   1              u15 = u15PC_PaperCW ;
1877   1              Delay(10);
1878   1              u15 = u15PC_PaperEnable;
1879   1              Delay(10);
1880   1              for (i=0;i<Packer.PgMode[USB.PgMode].Length;i++)
1881   1                      OneStep(Time_PaperMotorDelay);  
1882   1              u15 = u15PC_PaperDisable;
1883   1      }
1884          //-----------------------------------------------------------------------------
1885          void Delay(unsigned int DTime)
1886          {
1887   1      //      i=i<<1;
1888   1              while(DTime--)
1889   1              {
1890   2                      unsigned char DTime2=100;       // 1mSec
1891   2                      while(DTime2--);
1892   2      
1893   2              }
1894   1      }
1895          void i_Delay(unsigned int DTime)
1896          {
1897   1      //      i=i<<1;
1898   1              while(DTime--)
1899   1              {
1900   2                      unsigned char DTime2=100;       // 1mSec
1901   2                      while(DTime2--);
1902   2      
1903   2              }
1904   1      }
1905          
1906          //-----------------------------------------------------------------------------
1907          void PCA0_Init (void)
1908          {
1909   1         // Configure PCA time base; overflow interrupt disabled
1910   1         PCA0CN = 0x40;                      // Stop counter; clear all flags
1911   1         PCA0MD = 0x00;                      // Use SYSCLK as time base
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 32  

1912   1      
1913   1         PCA0CPM0 = 0x42;                    // Module 0 = 8-bit PWM mode
1914   1         PCA0CPM1 = 0x42;
1915   1         PCA0CPM2 = 0x42;
1916   1         // Configure initial PWM duty cycle = 50%
1917   1         PCA0CPH0 = 0x60;
1918   1         PCA0CPH1 = 0x40;
1919   1         PCA0CPH2 = 0x40;
1920   1         // Start PCA counter
1921   1         CR = 1;
1922   1      }
1923          //-----------------------------------------------------------------------------
1924          void OSCILLATOR_Init (void)
1925          {
1926   1         OSCICN = 0x83;                      // Set internal oscillator to run
1927   1                                             // at its maximum frequency
1928   1      
1929   1         CLKSEL = 0x00;                      // Select the internal osc. as
1930   1                                             // the SYSCLK source
1931   1         OSCICL = 0x10;
1932   1         CLKSEL |= 0x03;
1933   1         RSTSRC   |= 0x02;
1934   1      }
1935          //-----------------------------------------------------------------------------
1936          void OneStep(unsigned int time)
1937          {
1938   1              unsigned int d ;
1939   1      
1940   1              u15 = u15PC_PaperCKH;           
1941   1              d = time;       while(d--);
1942   1              u15 = u15PC_PaperCKL;           
1943   1              d = time;       while(d--);
1944   1              u15 = u15PC_PaperCKH;           
1945   1              d = time;       while(d--);
1946   1              u15 = u15PC_PaperCKL;           
1947   1              d = time;       while(d--);
1948   1              u15 = u15PC_PaperCKH;           
1949   1              d = time;       while(d--);
1950   1              u15 = u15PC_PaperCKL;           
1951   1              d = time;       while(d--);
1952   1      }
1953          
1954          //-----------------------------------------------------------------------------
1955          void SPI_Init()
1956          {
1957   1          SPI0CFG   = 0x40;
1958   1          SPI0CN    = 0x01;
1959   1              SPI0CKR   = 0x07;
1960   1      }
1961          void Timer0_Init(void)
1962          {
1963   1         TH0 = 0x30;//-31.25;           // Init Timer0 High register
1964   1         TL0 = TH0;                          // Set the intial Timer0 value
1965   1         TH1 = 0x30;
1966   1         TL1 = TH1;
1967   1         TMOD = 0x02;                        // Timer0 in 8-bit reload mode
1968   1         CKCON = 0x22;                       // Timer0 uses a 1:48 prescaler
1969   1         ET0 = 1;                              // Timer0 interrupt enabled
1970   1         ET1 = 1;
1971   1         TCON = 0x50;                        // Timer0 ON
1972   1      }
1973          void Timer1_ISR (void) interrupt 3
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 33  

1974          {
1975   1              TR1 = 0;
1976   1              /*
1977   1              if(Packer.Cpu1.VacuumType == VacuumType_HighSpeed || VacuumSW)
1978   1                      u15pc &= 0xFE;
1979   1              else if(Packer.Cpu1.VacuumType == VacuumType_LowSpeed)
1980   1                      u15pc &= 0xFD;
1981   1              else if(Packer.Cpu1.VacuumType == VacuumType_Stop || !VacuumSW)
1982   1                      u15pc |= 0x03;*/
1983   1              TempPWM ++;
1984   1              if(CarbonBTW)
1985   1              {
1986   2                      if(CarbonHall != CarbonTag)
1987   2                      {
1988   3                              CarbonTag = CarbonHall;
1989   3                              CarbonError = 0;
1990   3                      }
1991   2                      else
1992   2                      {                       
1993   3                              if(CarbonError ++ > 500)
1994   3                              {
1995   4                                      IsCarbonEntry = 1;
1996   4                                      CarbonError = 0;
1997   4                              }
1998   3                      }
1999   2              }
2000   1              AD0BUSY = 1;
2001   1              TR1 = 1;
2002   1      }
2003          void Timer0_ISR (void) interrupt 1
2004          {
2005   1              TR0=0;
2006   1      //      P2 &= 0x7F;
2007   1              _Sel = 1;
2008   1              switch(u14){
2009   2                      case u14PC_CarbonStop:
2010   2                              u14pc &= 0xFE;
2011   2                              break;
2012   2                      case u14PC_CarbonStart:
2013   2                              u14pc |= 0x01;
2014   2                              break;
2015   2                      case u14PC_PowderCoverStop:
2016   2                              u14pc &= 0xFD;
2017   2                              break;
2018   2                      case u14PC_PowderCoverStart:
2019   2                              u14pc |= 0x02;
2020   2                              break;
2021   2                      case u14PC_DrugCoverStop:
2022   2                              u14pc &= 0xFB;
2023   2                              break;
2024   2                      case u14PC_DrugCoverStart:
2025   2                              u14pc |= 0x04;
2026   2                              break;
2027   2                      case u14PC_PresureStop:
2028   2                              u14pc &= 0xF7;
2029   2                              break;
2030   2                      case u14PC_PresureStart:
2031   2                              u14pc |= 0x08;
2032   2                              break;
2033   2                      case u14PC_PowderRight:
2034   2                              //PCA0CPH0=0x60;
2035   2                              u14pc &= 0xEF;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 34  

2036   2                              break;
2037   2                      case u14PC_PowderLeft:
2038   2                              //PCA0CPH0=0x60;
2039   2                              u14pc |= 0x10;
2040   2                              break;
2041   2                      case u14PC_PowderStop:
2042   2                              u14pc &= 0xDF;
2043   2                              break;
2044   2                      case u14PC_PowderStart:
2045   2                              u14pc |= 0x20;
2046   2                              break;
2047   2                      case u14PC_DrugRight:
2048   2                              u14pc &= 0xBF;
2049   2                              break;
2050   2                      case u14PC_DrugLeft:
2051   2                              u14pc |= 0x40;
2052   2                              break;
2053   2                      case u14PC_DrugStop:
2054   2                              u14pc &= 0x7F;
2055   2                              break;
2056   2                      case u14PC_DrugStart:
2057   2                              u14pc |= 0x80;
2058   2                              break;
2059   2              }
2060   1              switch(u15){
2061   2                      case u15PC_PaperCKL:
2062   2                              u15pc &= 0xEF;
2063   2                              break;
2064   2                      case u15PC_PaperCKH:
2065   2                              u15pc |= 0x10;
2066   2                              break;
2067   2                      case u15PC_PaperCW:
2068   2                              u15pc &= 0xDF;
2069   2                              break;
2070   2                      case u15PC_PaperCCW:
2071   2                              u15pc |= 0x20;
2072   2                              break;
2073   2                      case u15PC_PaperEnable:
2074   2                              u15pc &= 0xBF;
2075   2                              break;
2076   2                      case u15PC_PaperDisable:
2077   2                              u15pc |= 0x40;
2078   2                              break;
2079   2                      case u15PC_CarbonON:
2080   2                              u15pc &= 0xFB;
2081   2                              break;
2082   2                      case u15PC_CarbonOFF:
2083   2                              u15pc |= 0x04;
2084   2                              break;
2085   2                      case u15PC_PaperPressON:
2086   2                              u15pc &= 0xFD;
2087   2                              break;
2088   2                      case u15PC_PaperPressOFF:
2089   2                              u15pc |= 0x03;
2090   2                              break;
2091   2                      case u15PC_SharkerON:
2092   2                              u15pc |= 0x08;
2093   2                              break;
2094   2                      case u15PC_SharkerOFF:
2095   2                              u15pc &= 0xF7;
2096   2                              break;
2097   2      
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 35  

2098   2              }
2099   1              if(TempPWM ++ > 0XFE)
2100   1                      TempPWM = 0;
2101   1              if(TempPWM < Packer.Cpu1.HeaterPWM)
2102   1              {
2103   2                      u15pc &= 0xFB;
2104   2              }
2105   1              else 
2106   1              {
2107   2                      u15pc |= 0x04;  
2108   2              }
2109   1      //      _u14pb(u14pb);
2110   1              _u14pc(u14pc);
2111   1              _u15pc(u15pc);
2112   1              _u14PAR();
2113   1              _u15PAR();
2114   1              /*
2115   1              if(PaperLPS == !PaperLSign && PaperLPS == 0)
2116   1                      PaperLTension ++;       
2117   1          if(PaperRPS == !PaperRSign && PaperRPS == 0)
2118   1                      PaperRTension ++;
2119   1              PaperLSign = PaperLPS;  
2120   1              PaperRSign = PaperRPS;*/
2121   1              _u15PBR();
2122   1      
2123   1              _Sel = 0;
2124   1              TR0=1;
2125   1      
2126   1      }
2127          
2128          //-----------------------------------------------------------------------------
2129          void PowderLocate()
2130          {
2131   1              Packer.Cpu1.State = Cpu1State_PowderLocating;
2132   1              AccessCpu0(Cpu0Command_ShowPowderLocating);                     
2133   1              Packer.Cpu1.Message = Message_PowderLocating;
2134   1              while(1)
2135   1              {
2136   2                      if(!PowderLSW)
2137   2                      {
2138   3                              Powder(MotorStop,0xFF);
2139   3                              Delay(1000);
2140   3                              CursorLocation = CursorRightEntry;
2141   3                              Dir = 1;
2142   3                              Powder(MotorRight,PowderPWM);
2143   3                              //Delay(1000);
2144   3                              while(!PowderLSW);
2145   3                      }
2146   2                      else if(!PowderRSW)
2147   2                      {
2148   3                              Powder(MotorStop,0xFF);
2149   3                              Delay(1000);
2150   3                              //Counter = 90;
2151   3                              CursorLocation = CursorLeftEntry;
2152   3                              
2153   3                              Powder(MotorLeft,PowderPWM);
2154   3                              //Delay(1000);
2155   3                              while(!PowderRSW);
2156   3                      }
2157   2                      if ( CursorLocation == CursorLeftEntry) //1
2158   2                      {
2159   3                              Powder(MotorLeft,PowderPWM);
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 36  

2160   3                              Dir = 0;
2161   3                      }
2162   2                      else if ( CursorLocation == CursorRightEntry)   //1
2163   2                      {
2164   3                              Powder(MotorRight,PowderPWM);
2165   3                              Dir = 1;
2166   3                      }
2167   2                      else if ( CursorLocation == CursorLeftHall )    //2
2168   2                      {
2169   3                              unsigned long l=0x60000;
2170   3                              Powder(MotorStop,0xFF);
2171   3                              Delay(5000);
2172   3                              Dir = 1;
2173   3                              Powder(MotorRight,0xA0);                
2174   3                              while (CursorLocation != CursorRightHall)
2175   3                              {                               
2176   4                                      if (l-- ==0 || !PowderRSW)
2177   4                                      {       
2178   5                                              Powder(MotorStop,0xFF);
2179   5                                              Delay(5000);
2180   5                                              CounterTag = PowderCounterPS;
2181   5                                              break;
2182   5                                      }
2183   4                              }
2184   3                              if (CursorLocation == CursorRightHall){
2185   4                                      break;
2186   4                              }
2187   3                      }
2188   2      
2189   2              }
2190   1              Powder(MotorStop,0xFF);
2191   1              Delay(6000);
2192   1              Packer.Cpu1.PowderLocation = Counter/2;
2193   1              CounterTag = PowderCounterPS;
2194   1              if(!PowderCounterPS == 0){
2195   2                      Packer.ErrorCode = ErrorCode_Powder ;
2196   2                      while(RHall == 0){
2197   3                              Packer.Cpu1.State = Cpu1State_Error ;
2198   3                              AccessCpu0(Cpu0Command_ShowCPU1ErrorCode);                                              
2199   3                              Delay(800);
2200   3                      }
2201   2                      Delay(1000);
2202   2                      Packer.ErrorCode = ErrorCode_NoError ;
2203   2                      PowderLocate();
2204   2              }
2205   1              Counter = Packer.Cpu1.PowderLocation * 2;
2206   1              Packer.Cpu1.State = Cpu1State_Idel ;
2207   1              AccessCpu0(Cpu0Command_ShowSystemReady);
2208   1              Packer.Cpu1.Message = Message_SystemReady ;
2209   1      }
2210          
2211          
2212          //================== ADC0 P0.4     =======================================
2213          void ADC0_Init (void)
2214          {
2215   1         REF0CN = 0x0B;                      // Enable on-chip VREF and buffer
2216   1      
2217   1         AMX0P = 0x13;                       // ADC0 positive input = P0.4
2218   1         AMX0N = 0x1F;                       // ADC0 negative input = GND
2219   1                                             // i.e., single ended mode
2220   1      
2221   1         ADC0CF = 0xF8;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 37  

2222   1      
2223   1         EIE1 |= 0x08;                       // enable ADC0 conversion complete int.
2224   1      
2225   1         AD0EN = 1;                          // enable ADC0
2226   1         AD0BUSY = 1;
2227   1      }
2228          unsigned int meanCount = 100; // Total number of bytes to read from host
2229          unsigned long accumulator = 0;     // Accumulator for averaging
2230          //unsigned long  mV;    // Measured voltage in mV
2231          unsigned int Tempture;
2232          //unsigned int result=0;
2233          //unsigned int ADC0ADD= 0;
2234          void ADC0_ISR (void) interrupt 10
2235          {
2236   1         AD0INT = 0;                               // Clear ADC0 conv. complete flag
2237   1      
2238   1         accumulator += ADC0L;
2239   1         accumulator = accumulator + ((ADC0H & 0x03) <<8);
2240   1      //   accumulator += ADC0;
2241   1         meanCount --;
2242   1      
2243   1      //      ADC0ADD = ADC0;
2244   1      
2245   1         if(meanCount==0)
2246   1         {  
2247   2            meanCount = 300; 
2248   2                Tempture = accumulator /meanCount / 5.265 + 25 ; 
2249   2                accumulator=0;
2250   2         }
2251   1      
2252   1      }
2253          //-----------------------------------------------------------------------------
2254          void ShowPackType()
2255          {
2256   1              if (Packer.Cpu0.PackType == PackType_Powder)
2257   1              {
2258   2                      AccessCpu0(Cpu0Command_ShowPackPowder);
2259   2                      Packer.Cpu1.Message = Message_PackPowder;
2260   2              }               
2261   1              else if (Packer.Cpu0.PackType == PackType_Drug)
2262   1              {
2263   2                      AccessCpu0(Cpu0Command_ShowPackDrug);
2264   2                      Packer.Cpu1.Message = Message_PackDrug;
2265   2              }
2266   1              else if (Packer.Cpu0.PackType == PackType_Mix)
2267   1              {
2268   2                      AccessCpu0(Cpu0Command_ShowPackMix);
2269   2                      Packer.Cpu1.Message = Message_PackMix;
2270   2              }
2271   1      }
2272          //-----------------------------------------------------------------------------
2273          void ShowPackTypeUSB()
2274          {
2275   1              if (USB.PackType == PackType_Powder)
2276   1              {
2277   2                      AccessCpu0(Cpu0Command_ShowPackPowder);
2278   2                      Packer.Cpu1.Message = Message_PackPowder;
2279   2              }               
2280   1              else if (USB.PackType == PackType_Drug)
2281   1              {
2282   2                      AccessCpu0(Cpu0Command_ShowPackDrug);
2283   2                      Packer.Cpu1.Message = Message_PackDrug;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 38  

2284   2              }
2285   1              else if (USB.PackType == PackType_Mix)
2286   1              {
2287   2                      AccessCpu0(Cpu0Command_ShowPackMix);
2288   2                      Packer.Cpu1.Message = Message_PackMix;
2289   2              }
2290   1      }
2291          //============================================================
2292          void UART1_Init (void){
2293   1      /*
2294   1              SBRLL1    = 0x3C;
2295   1          SBRLH1    = 0xF6;
2296   1          SCON1     = 0x10;           //埰勍UART1諉彶
2297   1          SMOD1     = 0x0E;
2298   1          SBCON1    = 0x43;  
2299   1      */
2300   1              SBRLL1    = 0x3C;
2301   1          SBRLH1    = 0xF6;
2302   1          SCON1     = 0x10;           //埰勍UART1諉彶
2303   1          SMOD1     = 0x0C;
2304   1          SBCON1    = 0x43; 
2305   1      }
2306          //-----------------------------------------------------------------------------
2307          
2308          void putchar(unsigned char cData)
2309          {
2310   1              unsigned int i=10000;
2311   1              while( (SCON1 & 0x20) ==0) ;
2312   1              SBUF1 = cData;
2313   1              if(cData == Packer.ErrorCode){
2314   2                      EIE2 |= 0x02;
2315   2                      SCON1&=0x3F;
2316   2              }
2317   1              while(i--);     
2318   1      }
2319          
2320          //-----------------------------------------------------------------------------
2321          char _getkey ()  {
2322   1          char c;
2323   1          while (!(SCON1 & 0x01));           // wait until UART1 receives a character
2324   1          c = SBUF1;                         // save character to local variable
2325   1          SCON1 &= ~0x01;                    // clear UART1 receive interrupt flag
2326   1          return (c);                        // return value received through UART1
2327   1      }
2328          //-----------------------------------------------------------------------------
2329          void DisableAllDriver()
2330          {
2331   1      //      Packer.Cpu1.HeaterPWM = TempPWM_OFF ;
2332   1              u14 = u14PC_CarbonStop ;
2333   1      //      IsCarbonStart =0;
2334   1      
2335   1              u14 = u14PC_PowderCoverStop ;
2336   1              u14 = u14PC_DrugCoverStop ;
2337   1      
2338   1              u14 = u14PC_PresureStop ;
2339   1              u14 = u14PC_PowderStop ;
2340   1              u14 = u14PC_DrugStop ;
2341   1      
2342   1              u15 = u15PC_PaperPressOFF ;
2343   1              Delay(10);
2344   1      //      u15 = u15PC_HeaterControlL      ;
2345   1              u15 = u15PC_SharkerOFF ;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 39  

2346   1              Delay(10);
2347   1              u15 = u15PC_PaperResetH ;
2348   1              Delay(10);
2349   1              u15 = u15PC_PaperDisable;
2350   1      }
2351          //-----------------------------------------------------------------------------
2352          void RxPackInfo()
2353          {
2354   1              xdata   byte *i,aa[39],j=0;
2355   1      
2356   1              EIE2 &= ~0x02;
2357   1      
2358   1              for ( i = &Packer.Cpu0.PackType ; i <= (&Packer.Cpu0.PackType +38); i ++)
2359   1              {       
2360   2                      while ( (SCON1 & 0x01) == 0);
2361   2                      SCON1 &= (~0x01);       // RI=0
2362   2                      *(i) = SBUF1;
2363   2                      aa[j] = *i;
2364   2                      j++ ;
2365   2              }
2366   1              BitPackParameter = Packer.Cpu0.BitPackParameter ;
2367   1              EIE2 |= 0x02;
2368   1      }
2369          //-----------------------------------------------------------------------------
2370          
2371          void AccessCPU0(ECpu1Command Command)
2372          {
2373   1              unsigned int i=0;
2374   1      //      Packer.Cpu1.PowderLocation = (PowderLocationCounter ) /2;
2375   1      //      Packer.Cpu1.Thermometer = Tempture;                                                              
2376   1              putchar(UART_Mark) ;
2377   1      
2378   1              putchar(Command);
2379   1      
2380   1              putchar(Packer.Cpu1.State);
2381   1      
2382   1              putchar(Packer.Cpu1.NowNumber);
2383   1      
2384   1              putchar(Packer.Cpu1.PowderLocation);
2385   1      
2386   1              putchar(Packer.Cpu1.Thermometer++);
2387   1      
2388   1              putchar(Packer.ErrorCode);
2389   1                      
2390   1      
2391   1              IsRxCommand =0;
2392   1              while(!IsRxCommand) 
2393   1              {
2394   2                      if (i++ >= 40000)       
2395   2                      {
2396   3                              i=0;
2397   3                              Pointer_Packer = &Packer.UART_Mark;
2398   3                              Packer.UART_Mark = UART_NoMark ;
2399   3                              Cpu1CommandIdel();
2400   3                              return;
2401   3                      }
2402   2              }
2403   1      
2404   1              if (Command == Cpu0Command_TxPackInfo)
2405   1              {
2406   2                      RxPackInfo();
2407   2              }
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 40  

2408   1              else 
2409   1              {
2410   2                      Delay(50);
2411   2              }
2412   1      
2413   1              Pointer_Packer = &Packer.UART_Mark ;
2414   1      
2415   1              if (Packer.Cpu0.State == Cpu0State_SettingMode)
2416   1              {
2417   2                      Delay(1000);
2418   2              }
2419   1              else if (Packer.Cpu0.State == Cpu0State_PackingMode)
2420   1              {
2421   2      //              if (Packer.UART_Mark == UART_Mark)
2422   2                      {
2423   3                              if (Packer.Cpu1.Command_UART == Cpu1Command_PackPause)
2424   3                              {
2425   4                                      IsPackPause = 1;
2426   4                                      Cpu1CommandIdel();
2427   4                              }
2428   3                              else if (Packer.Cpu1.Command_UART == Cpu1Command_PackStop ||
2429   3                                               Packer.Cpu1.Command_UART == Cpu1Command_PackContinue )
2430   3                              {
2431   4                                      IsPackPause = 0;
2432   4                              }
2433   3                              else if (Packer.Cpu1.Command_UART == Cpu1Command_Again)
2434   3                              {
2435   4                                      IsAgain = 1;
2436   4                              }
2437   3                      }
2438   2              }
2439   1      }
2440          //-----------------------------------------------------------------------------
2441          byte Cpu1Command()
2442          {
2443   1              if (Packer.Cpu1.Command_UART != Cpu1Command_Idel )
2444   1              {
2445   2                      return Packer.Cpu1.Command_UART;
2446   2              }
2447   1              else 
2448   1              {
2449   2                      return Packer.Cpu1.Command_USB;
2450   2              }
2451   1      }
2452          //-----------------------------------------------------------------------------
2453          void Cpu1CommandIdel()
2454          {
2455   1              Packer.Cpu1.Command_UART = Cpu1Command_Idel ;
2456   1              Packer.Cpu1.Command_USB  = Cpu1Command_Idel ;
2457   1      }
2458          //-----------------------------------------------------------------------------
2459          
2460          void UART1_ISR(void)   interrupt 16 
2461          {
2462   1              EIE2 &= ~0x02;
2463   1              if (SCON1 & 0x02)               // TI1
2464   1              {
2465   2                      SCON1 &= (~0x02);
2466   2              }
2467   1      
2468   1              if (SCON1 & 0x01 )              // RI1
2469   1              {
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 41  

2470   2                      SCON1 &= (~0x01);
2471   2                      *(Pointer_Packer) = SBUF1;
2472   2                      if(Pointer_Packer == &Packer.UART_Mark)
2473   2                      {
2474   3                              if (Packer.UART_Mark == UART_Mark)
2475   3                              {
2476   4                                      Packer.UART_Mark = UART_NoMark ;
2477   4                                      Pointer_Packer = & Packer.Cpu1.Command_UART ;
2478   4      
2479   4                                      RxTimeOutCount =0;
2480   4                                      TR2 =1;
2481   4                              }
2482   3                              else
2483   3                              {       
2484   4                                      Pointer_Packer = &Packer.UART_Mark;
2485   4                              }                       
2486   3                      }
2487   2                      else if(Pointer_Packer == & Packer.Cpu1.Command_UART)
2488   2                      {
2489   3                              Pointer_Packer = &Packer.Cpu0.State ;
2490   3                      }
2491   2                      else if(Pointer_Packer == &Packer.Cpu0.State)
2492   2                      {
2493   3                              Pointer_Packer = &Packer.UART_Mark;     
2494   3                              IsRxCommand = 1;
2495   3                              RxTimeOutCount =0;
2496   3                              TR2 =0; 
2497   3                      }
2498   2                      else 
2499   2                      {
2500   3                              Pointer_Packer = &Packer.UART_Mark;
2501   3      
2502   3                      }
2503   2      
2504   2              }
2505   1      
2506   1              EIE2 |= 0x02;
2507   1      }
2508          //-----------------------------------------------------------------------------
2509          void PowderCoverOpen()
2510          {
2511   1              unsigned char i;
2512   1              i = Packer.Cpu1.PowderCoverOpenNumber ;
2513   1              if (i>4) i=2;
2514   1      
2515   1              u14 = u14PC_PowderCoverStart ;
2516   1              Delay(50);
2517   1              while(i--)
2518   1              {
2519   2                      errorTime = Time_PowderCoverPS ;
2520   2                      do 
2521   2                      {
2522   3                              i_Delay(Time_PSDelay);
2523   3                              CheckErrorCode(ErrorCode_PowderCover);
2524   3                      } while(PowderCoverPS==1) ;
2525   2      
2526   2                      errorTime = Time_PowderCoverPS ;
2527   2                      do 
2528   2                      {
2529   3                              i_Delay(Time_PSDelay);
2530   3                              CheckErrorCode(ErrorCode_PowderCover);
2531   3                      } while(PowderCoverPS==0) ;
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 42  

2532   2              }
2533   1              u14 = u14PC_PowderCoverStop ;
2534   1              Delay(800);
2535   1      }
2536          //-----------------------------------------------------------------------------
2537          void CheckErrorCode(EErrorCode ECode)
2538          {
2539   1              if (errorTime-- == 0)
2540   1              {
2541   2                      DisableAllDriver();
2542   2      
2543   2                      Packer.ErrorCode = ECode ;
2544   2                      while(1)
2545   2                      {
2546   3                              Packer.Cpu1.State = Cpu1State_Error ;
2547   3                              AccessCpu0(Cpu0Command_ShowCPU1ErrorCode);      
2548   3                              //AccessUSB(USBCommand_Busy);                                   
2549   3                              Delay(800);
2550   3                      }
2551   2              }
2552   1      }
2553          //-----------------------------------------------------------------------------
2554          void AutoClear()
2555          {
2556   1              Packer.Cpu1.PowderLocation =0;  
2557   1              Packer.Cpu1.State = Cpu1State_Clearing;
2558   1      
2559   1              AccessCpu0(Cpu0Command_ShowClearing);                   
2560   1      //      AccessUSB(USBCommand_Busy);     
2561   1      
2562   1              if (PaperMotorPS != 1)
2563   1              {
2564   2                      PaperMotorLocate();             
2565   2              }
2566   1              Packer.Cpu1.VacuumType = VacuumType_HighSpeed ;
2567   1              Delay(10);
2568   1              PowderToLeft();
2569   1      
2570   1      
2571   1              CursorLocation = CursorRightEntry ;
2572   1              PowderCounterPS_LastState = PowderCounterPS ;
2573   1      
2574   1              PowderLocationCounter = 0;
2575   1              PowderLocate();
2576   1      
2577   1              Packer.Cpu1.VacuumType = VacuumType_Stop ;
2578   1              Delay(10);
2579   1              Packer.Cpu1.State = Cpu1State_Idel ;
2580   1              AccessCpu0(Cpu0Command_ShowSystemReady);
2581   1      //      AccessUSB(USBCommand_Idel);     
2582   1      }
2583          //-----------------------------------------------------------------------------
2584          
2585          void HeadWithPrint()
2586          {
2587   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8566    ----
   CONSTANT SIZE    =  15108    ----
   XDATA SIZE       =  57215      43
C51 COMPILER V9.51   PRINTER                                                               09/08/2018 12:59:12 PAGE 43  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45      49
   IDATA SIZE       =     63    ----
   BIT SIZE         =     20       7
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
